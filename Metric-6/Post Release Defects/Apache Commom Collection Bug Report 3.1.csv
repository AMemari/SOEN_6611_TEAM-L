Summary,Issue key,Issue id,Issue Type,Status,Project key,Project name,Project type,Project lead,Project description,Project url,Priority,Resolution,Assignee,Reporter,Creator,Created,Updated,Last Viewed,Resolved,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Fix Version/s,Fix Version/s,Component/s,Component/s,Due Date,Votes,Labels,Labels,Labels,Description,Environment,Original Estimate,Remaining Estimate,Time Spent,Work Ratio,Σ Original Estimate,Σ Remaining Estimate,Σ Time Spent,Security Level,Outward issue link (Duplicate),Outward issue link (Reference),Outward issue link (dependent),Attachment,Attachment,Attachment,Custom field (Attachment count),Custom field (Blog - New Blog Administrators),Custom field (Blog - New Blog PMC),Custom field (Blog - Write access),Custom field (Blog Administrator?),Custom field (Blogs - Admin for blog),Custom field (Blogs - Email Address),Custom field (Blogs - Existing Blog Access Level),Custom field (Blogs - Existing Blog Name),Custom field (Blogs - New Blog Write Access),Custom field (Blogs - Username),Custom field (Bug Category),Custom field (Bugzilla - Email Notification Address),Custom field (Bugzilla - List of usernames),Custom field (Bugzilla - PMC Name),Custom field (Bugzilla - Project Name),Custom field (Bugzilla Id),Custom field (Change Category),Custom field (Complexity),Custom field (Date of First Response),Custom field (Discovered By),Custom field (Docs Text),Custom field (Enable Automatic Patch Review),Custom field (Epic Link),Custom field (Existing GitBox Approval),Custom field (External issue ID),Custom field (External issue URL),Custom field (Flags),Custom field (Flags),Custom field (Git Notification Mailing List),Custom field (Git Repository Import Path),Custom field (Git Repository Name),Custom field (Git Repository Type),Custom field (GitHub Options),Custom field (Github Integration),Custom field (Github Integrations - Other),Custom field (Global Rank),Custom field (INFRA - Subversion Repository Path),Custom field (Initial Confluence Contributors),Custom field (Last public comment date),Custom field (Machine Readable Info),Custom field (New-TLP-TLPName),Custom field (Priority),Custom field (Project),Custom field (Protected Branch),Custom field (Rank),Custom field (Rank (Obsolete)),Custom field (Severity),Custom field (Severity),Custom field (Source Control Link),Custom field (Space Description),Custom field (Space Key),Custom field (Space Name),Custom field (Test and Documentation Plan),Custom field (Testcase included),Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment
[collections] PriorityBuffer ignores natural order of elements,COLLECTIONS-75,12342083,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Blocker,Incomplete,,bobik72@freenet.de,bobik72@freenet.de,01/Mar/05 23:52,16/May/06 12:16,10/Jun/19 03:21,16/May/06 12:16,3.1,,,,,,,,,,0,,,,"The following code snippet:
-------------------------------
PriorityBuffer r = new PriorityBuffer();
r.add(new Integer(2));
r.add(new Integer(1));
r.add(new Integer(0));
for (Iterator it = r.iterator(); it.hasNext(); )
	System.out.println("":""+it.next());
-------------------------------
Prints this
:0
:2
:1","Operating System: All
Platform: All",,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,33788.0,,,,,,false,,,,,,,,,,,,,,18923,,,Wed Mar 02 00:16:26 UTC 2005,,,,,,0|i0sjhb:,164633,,,,,,,,,"02/Mar/05 00:16;bobik72@freenet.de;Ok I noticed you have to use remove() to access elements in the natural order.
The  javadoc API could be a bit more specific about that - there is no word
about remove() returning elems in natural order and iterator() returning elems
in random order. As a matter of fact, an iterator in natural order would be useful.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,
HashEntry array object naming data initialized with double the size during deserialization,COLLECTIONS-599,13025071,Bug,Open,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Critical,,,tejast5,tejast5,02/Dec/16 11:58,02/Feb/18 10:10,10/Jun/19 03:21,,3.1,,,,,4.1,,Collection,Map,,0,,,,"Common collections 3.1 and 3.2 are used at many places and frameworks including struts2. 
Supose a LinkedMap object it is created and have size greater than zero is serialized. While deserializing this object , array of HashEntry naming data delacred in AbstractHashedMap always initialises with a new capacity of double its double of the serialized object. 

Please see the below API declared in AbstractHashedMap class :

{code:java}
protected void checkCapacity()
  {
    if (this.size >= this.threshold)
    {
      int newCapacity = this.data.length * 2;
      if (newCapacity <= 1073741824) {
        ensureCapacity(newCapacity);
      }
    }
  }
{code}",,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2017-11-06 06:16:19.289,,,false,,,,,Important,,,,,,,,,9223372036854775807,,,Fri Feb 02 10:10:00 UTC 2018,,,,,,0|i372nr:,9223372036854775807,,,,,,,,,"02/Dec/16 12:05;tejast5;Possible fix would be calculating threshold before putting the data in doReadObject API. 
Calculating threshold would not initialize the array by double.
Please find the code below : 

{code:java}
protected void doReadObject(ObjectInputStream in)
    throws IOException, ClassNotFoundException
  {
    this.loadFactor = in.readFloat();
    int capacity = in.readInt();
    int size = in.readInt();
    init();
    this.data = new HashEntry[capacity];
    this.threshold = calculateThreshold(this.data.length, this.loadFactor);
    for (int i = 0; i < size; i++)
    {
      Object key = in.readObject();
      Object value = in.readObject();
      put(key, value);
    }
    
  }
{code}

Why these is critical because this version of jar are been used by struts 2 . 
I saw these been changed in version 4.1 , but if you classes in 4.1 are declared in different package.
We should have provide fix for these version as we cant change jars which is internally using these stuff. 

",06/Nov/17 06:16;mingleizhang;Does anyone give me a permission that can contribute code to apache/commons ? Thank you very much! Minglei.,"06/Nov/17 15:55;ggregory;Hi [~mingleizhang],

Please feel free to provide a pull request on GitHub with a unit test.

https://github.com/apache/commons-collections

Are you expecting that such a change would be in the 3.x AND 4.x (master) branches?

Gary","07/Nov/17 01:30;mingleizhang;Hi, [~garydgregory] I would think this change should be in 3.X, then 4.X master branches can rebase code from 3.X. As I found its affects versions is 3.1.","07/Nov/17 02:09;mingleizhang;I suspect that whether this issue belongs to a bug, instead, I think it should be a performance issue.","07/Nov/17 02:09;mingleizhang;I suspect that whether this issue belongs to a bug, instead, I think it should be a performance issue.","01/Feb/18 17:50;saleem-akbar;I also came across this problem (in my scenario I ended up with an out-of-memory error using non-sticky session replication) and also figured out the same solution, which was to to calculate the threshold before populating the data.

 

Anyway, I've submitted the following PR's for 3.2.x (we're currently using 3.2.2) and master.

[https://github.com/apache/commons-collections/pull/34]

[https://github.com/apache/commons-collections/pull/35]

 

If approved, could we please have an official 3.2.x release (at this point 3.2.3) asap?

 

Cheers

Saleem

 

 ",01/Feb/18 18:51;ggregory;The fix has been committed to git master. I re-wrote the unit test method to use Java 7 idioms.,"02/Feb/18 10:10;saleem-akbar;Thanks :-)

",,,,,,,,,,,,,,,,,,,,,
containsKey on MultiHashMap seems incorrect,COLLECTIONS-250,12368186,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Critical,Invalid,jwcarman,ngd,ngd,27/Apr/07 10:24,15/Mar/08 21:36,10/Jun/19 03:21,30/Apr/07 10:56,3.1,3.2,,,,,,Map,,,0,,,,"
MultiHashMap m = new MultiHashMap();
m.putAll(""key"", Collections.EMPTY_LIST);
System.out.println(m.containsKey(""key"")) 

It says false, when it should have printed true. 

The problem is that the code in MultiHashMap and even MultiValueMap has in putAll():

if (values == null || values.size() == 0) 
{
            return false;
}

This means that they key is never being entered into the Map. This is causing a huge problem because the behaviour has changed.

",,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2007-04-27 19:39:51.64,,,false,,,,,,,,,,,,,,18749,,,Mon Apr 30 10:56:30 UTC 2007,,,,,,0|i0sihj:,164472,,,,,,,,,27/Apr/07 19:39;jwcarman;The behavior has changed from what?  The Map API?,"29/Apr/07 20:10;bayard;It seems very correct to me - putAll(key, EMPTY_LIST) is a no-op. I'm not sure what behaviour has changed here - these methods haven't changed since they were added in r131607.","30/Apr/07 10:36;ngd;It's not changed, my mistake. 

Just as in a regular map that containsKey(key) is not equivalent to getValue(key) != null, i.e. after doing a put(key, null), containsKey(key), still returns true, I am expecting something similar. I find it wierd that after doing a putAll(key, LIST), containsKey(key) returns FALSE, it should return an empty list. 

My problem is this (maybe this is not to be discussed here, but I think it is appropriate at least to put the problem forward): I use MultiHashMap (MHM) for caching database results of 1-to-many relationships. Let's say its is a PERSON borrowed BOOKS relation. So, I do one SQL query to fetch all the books for many (not all) persons and then populate the MHM cache (SELECT book_id from BorrowedBooks where person_id in (id1, id2, id3...)). After populating, the MHM has person1->books borrowed by person1, person2->books borrwed by person2 etc. Now, a query comes asking for books borrowed by personX. Since there is no way of asking the MHM whether ""this key has no entries"", if I don't find the personX's key in the MHM, it is unclear if the caching query had fetched personX's id in the original query. If there was a way, of maintaining empty collections in the MHM, then this problem can be solved. 

Also there is no way to put an empty list for a key which I could have used as  workaround.",30/Apr/07 10:54;jwcarman;Just use a set along side the map to keep track of which persons have had their books cached.,30/Apr/07 10:56;jwcarman;I believe we have established that this is the desired functionality.  Changing it now would break other code which relies upon the existing behavior.,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] LRUMap loses values when resizing.,COLLECTIONS-51,12342936,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Critical,Incomplete,,davedandeneau@yahoo.com,davedandeneau@yahoo.com,23/Feb/06 01:15,15/Mar/08 21:35,10/Jun/19 03:21,15/Mar/08 21:35,3.1,,,,,,,,,,0,,,,"I am using the LRUMap and I have noticed that when it resizes the Map it loses
the values that were in it previously. I noticed this when it was resizing my
map from size of 2 to size of 4.","Operating System: Windows XP
Platform: PC",,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,38753.0,,,2006-02-23 01:25:11.0,,,false,,,,,,,,,,,,,,18947,,,Thu Feb 23 01:47:43 UTC 2006,,,,,,0|i0sjmn:,164657,,,,,,,,,23/Feb/06 01:25;gudnabrsam@yahoo.com;Got any sample code to evoke the bug?,23/Feb/06 01:47;davedandeneau@yahoo.com;This appears to not be a problem with LRUMap. ,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Deserialization and Apache Commons Collection,COLLECTIONS-581,12911814,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Invalid,markt,deepeshkapoor,deepeshkapoor,10/Nov/15 09:55,27/Nov/15 21:47,10/Jun/19 03:21,10/Nov/15 10:00,3.0,3.1,3.2.1,,,,,Functor,,,0,patch,,,"Hi Team,

This is regarding “commons-collections Java library”. In our applications we are widely using this library and hence looking to urgently patch the fix for vulnerability issue if it is available.
Searching on internet we found one patch released on Sunday 08th Nov http://svn.apache.org/viewvc?view=revision&revision=1713307

Just wanted to check with you if there is any updated / complied version of commons-collections jar available or going to be released soon which we can directly replace with our existing jar file that provides the fix for the vulnerability issue.

Thanks in advance!
",,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2015-11-10 10:00:04.388,,,false,,,,,Important,Patch,,,,,,,,9223372036854775807,,,Tue Nov 10 10:06:38 UTC 2015,,,,,,0|i2o6qn:,9223372036854775807,,,,,,,,,10/Nov/15 10:00;markt;Jira is not the place to ask support questions. Please use the mailing list.,"10/Nov/15 10:06;deepeshkapoor;Thanks Mark, i have dropped an email to 'dev@commons.apache.org' and  'security@apache.org'. Kindly let me know if this is fine.


",,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Inconsistent Javadoc comment and code in addAll(Collection, Object[]) in org.apache.commons.collections.CollectionUtils",COLLECTIONS-385,12528956,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Not A Problem,,shinhwei,shinhwei,26/Oct/11 20:27,27/Nov/15 21:47,10/Jun/19 03:21,26/Jul/12 21:06,2.1,2.1.1,3.0,3.1,3.2,,,Collection,,,0,javadoc,nullpointerexception,,"The Javadoc comment below states that the method ""throws NullPointerException if the collection or array is null"". 
    /** 
     * Adds all elements in the array to the given collection.
     * 
     * @param collection  the collection to add to, must not be null
     * @param elements  the array of elements to add, must not be null
     * @throws NullPointerException if the collection or array is null
     */
    public static void addAll(Collection collection, Object[] elements) {
        for (int i = 0, size = elements.length; i < size; i++) {
            collection.add(elements[i]);
        }
    }    

However, when called with an empty array and a null collection (i.e., ""addAll((Collection)null, new Object[])""), the method executes normally without throwing any exception.

Suggested Fixes:
1. Add code ""if (collection == null) throw NullPointerException();"" at the beginning of the method body.
or
2. Remove ""@throws NullPointerException if the collection or array is null"" from the Javadoc.
or
3. Change ""@throws NullPointerException if the collection or array is null"" to ""@throws NullPointerException if the array is null or (the array is non-empty and the collection is null)"".",Platform Independent,300,300,,0%,300,300,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2011-10-29 21:11:47.1,,,false,,,,,,,,,,,,,,214816,,,Sun Oct 30 00:51:03 UTC 2011,,,,,,0|i0shuv:,164370,,,,,,,,,"29/Oct/11 20:41;shinhwei;I found the same problem for overloaded method CollectionUtils#public static void addAll(Collection collection,Iterator iterator) and CollectionUtils#public static void addAll(Collection collection,Enumeration enumeration)",29/Oct/11 21:11;ggregory;I do not think this applies to trunk.,"30/Oct/11 00:51;shinhwei;Yes, the trunk currently have:

           /**
	     * Adds all elements in the iteration to the given collection.
	     *
	     * @param collection
	     *            the collection to add to, must not be null
	     * @param iterator
	     *            the iterator of elements to add, must not be null
	     * @return a boolean indicating whether the collection has changed or not.
	     * @throws NullPointerException
	     *             if the collection or iterator is null
	     */
	    public static <C> boolean addAll(Collection<C> collection, Iterator<? extends C> iterator) {
	        boolean changed = false;
	        while (iterator.hasNext()) {
	            changed |= collection.add(iterator.next());
	        }
	        return changed;
	    }

           /**
	     * Adds all elements in the array to the given collection.
	     *
	     * @param collection
	     *            the collection to add to, must not be null
	     * @param elements
	     *            the array of elements to add, must not be null
	     * @throws NullPointerException
	     *             if the collection or array is null
	     */
	    public static <C> boolean addAll(Collection<C> collection, C[] elements) {
                 ............
            }

           /**
	     * Adds all elements in the iteration to the given collection.
	     *
	     * @param collection
	     *            the collection to add to, must not be null
	     * @param iterator
	     *            the iterator of elements to add, must not be null
	     * @return a boolean indicating whether the collection has changed or not.
	     * @throws NullPointerException
	     *             if the collection or iterator is null
	     */
	    public static <C> boolean addAll(Collection<C> collection, Iterator<? extends C> iterator) {

           /**
	     * Adds all elements in the iteration to the given collection.
	     *
	     * @param collection
	     *            the collection to add to, must not be null
	     * @param iterator
	     *            the iterator of elements to add, must not be null
	     * @return a boolean indicating whether the collection has changed or not.
	     * @throws NullPointerException
	     *             if the collection or iterator is null
	     */
	    public static <C> boolean addAll(Collection<C> collection, Iterator<? extends C> iterator) {
                    .....
            }

When called with an empty iterator/elements and a null collection (i.e., ArrayList al=new ArrayList(); addAll((Collection)null, new al.iterator())""), the method still executes normally without throwing any exception.",,,,,,,,,,,,,,,,,,,,,,,,,,,
Inconsistent Javadoc comment and code for synchronizedMap(Map) in org.apache.commons.collections.MapUtils,COLLECTIONS-384,12528955,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,shinhwei,shinhwei,26/Oct/11 20:21,09/Nov/14 14:31,10/Jun/19 03:21,29/Oct/11 20:54,3.0,3.1,3.2,,,4.0,4.0-alpha1,Collection,,,0,code,javadoc,synchronizedMap,"The Javadoc comment below states that the method ""throws IllegalArgumentException if the map is null"":
    /**
     ...
     * @param map  the map to synchronize, must not be null
     * @return a synchronized map backed by the given map
     * @throws IllegalArgumentException  if the map is null
     */
    public static Map synchronizedMap(Map map) {
        return Collections.synchronizedMap(map);
    }

However, the method throws NullPointerException instead of IllegalArgumentException when called with null.

Suggested Fixes:
1. Add code ""if (map == null) throw IllegalArgumentException();"" at the beginning of the method body.
or
2. Change ""@throws IllegalArgumentException  if the map is null"" to ""@throws NullPointerException  if the map is null"".
or
3. Remove the entire ""@throws IllegalArgumentException  if the map is null"".",Platform independent,300,300,,0%,300,300,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2011-10-29 20:52:18.267,,,false,,,,,,,,,,,,,,214815,,,Sat Oct 29 21:07:45 UTC 2011,,,,,,0|i0shv3:,164371,,,,,,,,,"29/Oct/11 20:52;ggregory;I picked option (3) because {{Collections.synchronizedMap(map);}} says nothing on the topic so I do not think it should be part of our contract. 

In fact our method seems superfluus. Why use it instead of Collections.synchronizedMap(map)?",29/Oct/11 20:54;ggregory;Committed revision 1195031.,"29/Oct/11 21:07;hudson;Integrated in commons-collections #2 (See [https://builds.apache.org/job/commons-collections/2/])
    [COLLECTIONS-384] Inconsistent Javadoc comment and code for synchronizedMap(Map) in org.apache.commons.collections.MapUtils.

ggregory : http://svn.apache.org/viewvc/?view=rev&rev=1195031
Files : 
* /commons/proper/collections/trunk/src/java/org/apache/commons/collections/MapUtils.java
",,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] ExtendedProperties#convertProperties doesn't inherit defaults.,COLLECTIONS-113,12341867,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,shinobu,shinobu,13/Nov/04 00:44,02/May/13 02:28,10/Jun/19 03:21,15/Mar/08 21:36,3.1,,,,,,,,,,0,,,,"ExtendedProperties#convertProperties() uses props.keys() instead of 
props.propertyNames(), causing the defaults properties to be discarded.","Operating System: other
Platform: Other",,,,,,,,,,,VELOCITY-333,13/Nov/04 00:49;shinobu;ASF.LICENSE.NOT.GRANTED--ExtendedProperties.defaults.patch;https://issues.apache.org/jira/secure/attachment/12333232/ASF.LICENSE.NOT.GRANTED--ExtendedProperties.defaults.patch,01/Dec/04 17:51;shinobu;ASF.LICENSE.NOT.GRANTED--ExtendedProperties.defaults.test.patch;https://issues.apache.org/jira/secure/attachment/12333233/ASF.LICENSE.NOT.GRANTED--ExtendedProperties.defaults.test.patch,,2.0,,,,,,,,,,,,,,,,32204.0,,,2005-05-23 08:05:19.0,,,false,,,,,,,,,,,,,,18885,,,Mon May 23 08:05:19 UTC 2005,,,,,,0|i0sj8v:,164595,,,,,,,,,"13/Nov/04 00:49;shinobu;Created an attachment (id=13418)
Patch to fix bug.
","01/Dec/04 17:51;shinobu;Created an attachment (id=13605)
Patch for the test.
","23/May/05 08:05;scolebourne@joda.org;Patches applied, thanks",,,,,,,,,,,,,,,,,,,,,,,,,,,
NPE: map.LRUMap.reuseMapping(LRUMap.java:272),COLLECTIONS-3,12341922,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Cannot Reproduce,,otis@apache.org,otis@apache.org,08/Dec/04 03:39,28/Feb/13 19:53,10/Jun/19 03:21,17/Jun/09 09:48,3.1,,,,,,,Map,,,2,,,,"I'm using Collections 3.1 and just found this NPE in my logs:

java.lang.NullPointerException
        at
org.apache.commons.collections.map.LRUMap.reuseMapping(LRUMap.java:272)
        at
org.apache.commons.collections.map.LRUMap.addMapping(LRUMap.java:243)
        at
org.apache.commons.collections.map.AbstractHashedMap.put(AbstractHashedMap.java:282)

I instantiated LRUMap like this:

  LRUMap map = new LRUMap(31);

And from there on, I use it like I'd use any Map, putting things into
it, and so on.  Maybe I'm not using LRUMap correctly?  My _guess_ is
that this occurs when the Map is full, but I am not certain.

I am wrapping the LRUMap in my own Maps as follows, but I think they're
not the culprit:

  LRUMap map = new LRUMap(31);
    _userSessions = new ExpiringMap(map,
       new TimerTTLReferenceHolder(1800000), // ttl=30min
       300000);                              // purge frequency=5min


The only similar thing I found is COM-1288, but it looks like that was fixed
before 3.1 release.

I understand the value of a self-contained unit test that demonstrates this bug,
but it happens only occassionally on my production system, never during
development, so I can't really come up with it :(

My guess is that this is a boundary case, as line 272 is:

 loop = loop.next;

So 'loop' is most likely null, and it's null because ... not sure, maybe that
hashIndex is wrong.","Operating System: Linux
Platform: PC",,,,,,,,,,COLLECTIONS-330,,12/Oct/05 05:40;scolebourne@joda.org;ASF.LICENSE.NOT.GRANTED--LRUMap.java;https://issues.apache.org/jira/secure/attachment/12333276/ASF.LICENSE.NOT.GRANTED--LRUMap.java,08/Oct/05 22:34;scolebourne@joda.org;ASF.LICENSE.NOT.GRANTED--SoakLRUMap.java;https://issues.apache.org/jira/secure/attachment/12333275/ASF.LICENSE.NOT.GRANTED--SoakLRUMap.java,08/Oct/05 22:32;scolebourne@joda.org;ASF.LICENSE.NOT.GRANTED--commons-collections-3.2-LRUMap-debug.jar;https://issues.apache.org/jira/secure/attachment/12333274/ASF.LICENSE.NOT.GRANTED--commons-collections-3.2-LRUMap-debug.jar,3.0,,,,,,,,,,,,,,,,32573.0,,,2005-02-04 09:28:55.0,,,false,,,,,,,,,,,,,,18995,,,Wed Jun 17 09:48:47 UTC 2009,,,,,,0|i0sjxb:,164705,,,,,,,,,"04/Feb/05 09:28;scolebourne@joda.org;Just a thought, but could your keys be changing after you insert them into the
map? Hash keys need to be immutable (or not changed) after being added as a key
in a map.","02/Mar/05 01:11;kreiger;I have a customer reporting the same problem, and i'm using java.lang.Integer
for the keys, and java.lang.ref.SoftReference for the values.","02/Mar/05 01:20;kreiger;Sorry, wrong. I'm using array of SoftReference (SoftReference[]) for the values.","20/Mar/05 04:13;endo@sb.net;Hello I am reporting a similar problem which makes LRUMap useless.  I am using 
LRUMap as a synchronizedMap.  I can confirm that this problem only occurs when 
the LRUMap becomes full, but not right away.  The problem may or may not arise 
(there is no pattern).  I am using LRUMap in a web environment to cache some 
stuff - the cache size is 40000.  Once the problem starts the problem 
continues with each next put.

java.lang.NullPointerException 
org/apache/commons/collections/map/LRUMap.addMapping
(IILjava/lang/Object;Ljava/lang/Object;)V+0 (LRUMap.java:227) 
org/apache/commons/collections/map/AbstractHashedMap.put
(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;+0 
(AbstractHashedMap.java:269) 
java/util/Collections$SynchronizedMap.put(Ljava/lang/Object;Ljava/lang/Object;)
Ljava/lang/Object;+11 (Collections.java:1432) 
","22/Mar/05 09:54;scolebourne@joda.org;I can reproduce this by not synchronizing access to the LRUMap.

Thus there are now two possible causes of this:
- Mutable keys (map keys must not be changed)
- Not correctly synchronized (use Collections.synchronizedMap)

Please check your code to ensure that you are using the collections correctly.","02/Apr/05 03:05;michael_girard@msn.com;we are also seeing this issue when using Strings as keys into the LRUMap. We are
using the Collections.synchronizedMap() call to synchronize access to the map as
well.

It also appears to us that this occurs when the cache fills.","02/Apr/05 04:15;otis@apache.org;This happening when the cache fills up was also something that I think was
happening when I saw the error.  Oh, I see I mentioned that in the original bug
report. :)","17/Jul/05 09:06;scolebourne@joda.org;I've just spent another 3 hours looking at this without finding anything, yet
with four separate bug reports here I guess there must be a problem :-(

Can any of you assist by answering the following:

What methods on LRUMap are you calling?
eg. get(), put(), iterator(), ...

Are any of you able to put a debug version of the jar into the environment that
causes the problem? Or have a way to reproduce it?","17/Jul/05 11:38;otis@apache.org;I'm no longer using the LRUMap, but I was using only put and get.  I know Kevin
Burton (another Apache guy) is seeing the same problems...","08/Oct/05 22:32;scolebourne@joda.org;Created an attachment (id=16622)
jar file

Jar file with additional debugging statements.

If anybody is able to run this and report back the debug, we would be most
grateful.","08/Oct/05 22:34;scolebourne@joda.org;Created an attachment (id=16623)
java file

My attempt at a test class to soak the LRUMap as in production","09/Oct/05 06:05;mliberato@gmail.com;That really seems a synchronization issue on the client. I have done some tests
here and the problem only occurs when there are non-thread-safe access to the
map. Are there more references to this kind of error?","09/Oct/05 06:45;scolebourne@joda.org;(In reply to comment #12)
> That really seems a synchronization issue on the client. I have done some tests
> here and the problem only occurs when there are non-thread-safe access to the
> map. Are there more references to this kind of error?

All the info is here in Bugzilla. It is only LRUMap that has issues against it,
other (similarly designed) classes have no issues raised.
","09/Oct/05 12:37;otis@apache.org;I'm no longer using this LRUMap in the application where I was having problems
with it, so I can't help retest/debug it in production any more.","10/Oct/05 21:56;kreiger;I can verify that when i wrapped the LRUMap in Collections.synchronizedMap(),
the problem went away.","12/Oct/05 05:40;scolebourne@joda.org;Created an attachment (id=16665)
java file

Java source code for LRUMap with debugging","11/Nov/05 09:13;scolebourne@joda.org;Can anyone who remembers please comment and state which JDK version, JDK vendor
and operating system they were using.

Thanks!","11/Nov/05 14:34;otis@apache.org;I (the original reporter of this bug) was using JDK 1.5 (beta-something,
probably whatever was the latest available beta in December 2004 when I reported
this bug.
","22/Nov/05 00:25;jhecking@netgaroo.com;Sorry, didn't mean to close the bug!

Re. comment #17 - we're running into the same problem when using LRUMap without
Collections.synchronizedMap(). Here's the requested info about JRE and OS version:

$ java -version
java version ""1.4.2_07""
Java(TM) 2 Runtime Environment, Standard Edition (build 1.4.2_07-b05)
Java HotSpot(TM) Client VM (build 1.4.2_07-b05, mixed mode)

$ uname -a
Linux XXX 2.6.9-5.ELsmp #1 SMP Wed Jan 5 19:30:39 EST 2005 i686 i686 i386 GNU/Linux

The NPE occurs when calling LRUMap.put(). The key is immutable (String). We're
only using the put() and get() methods.","22/Nov/05 03:05;rdonkin@apache.org;Hi Jan

Thanks for the information.

Are you really running without synchronisation?

Is there any chance that mutliple threads are accessing the map?

Robert","22/Nov/05 03:29;jhecking@netgaroo.com;(In reply to comment #20)
> Are you really running without synchronisation?
Yes, before we hit this bug we were running without synchronization. Now we
wrapped the LRUMap in a Collections.synchronizedMap().

> Is there any chance that mutliple threads are accessing the map?
Yes, multiple threads are reading and writing the map.

Off course in this case it was stupid to not use synchronized access in the
first place as LRUMap does not explicitly state that it is threadsafe...","22/Nov/05 04:57;rdonkin@apache.org;Thanks for the information. I expect occasional null pointers when this map is
used by multiple threads without synchronization. I'll take a look at fixing the
javadocs. 

Have you had any problems since switching to use the synchronized version?

Robert","13/Apr/06 06:36;eric@pandora.com;I'm currently experiencing an identical problem to what Jan has already reported.

> uname -a
Linux <snip> 2.6.13.1-20050914 #2 SMP Wed Sep 14 13:54:47 PDT 2005 i686 GNU/Linux

> vmjava -version
java version ""1.4.1_07""
Java(TM) 2 Runtime Environment, Standard Edition (build 1.4.1_07-b02)
Java HotSpot(TM) Client VM (build 1.4.1_07-b02, mixed mode)

I'm running Jakarta Commons Collections 3.1.

Like Jan, the NPE occurs when calling LRUMap.put(). The key is immutable
(String), and we're only using the put() and get() methods. The offending LRUMap
is contructed using the LRUMap(int) constructor.

Once the NPE exception within LRUMap.put occurs, all subsequent calls to that
method also provoke a NPE.

We *are* decorating our LRUMap using Collections.synchronizedMap, and the
problem still occurs.","13/Apr/06 08:17;scolebourne@joda.org;(In reply to comment #23)
Are you able to use the debug jar file from comment #10 ?
It would be great if you could.

Also, can you confirm that all iterator access to the map is wrapped as follows:

synchronized {
  Iterator it = map.keySet().iterator();
  while (it.hasNext()) {
    ...
  }
}

ie. that there is a synchronized block around the whole of any iteration?","01/Jul/07 02:54;bayard;That should be:

synchronized(map) {

Playing with SoakLRUMap, not doing that gives a ConcurrentModificationException, which hasn't been reported so far. 

Mostly I get IllegalStateExceptions when playing with SoakLRUMap and not synchronizing the Map, however I did get one NPE still:

java.lang.NullPointerException
        at org.apache.commons.collections.map.LRUMap.moveToMRU(LRUMap.java:194)
        at org.apache.commons.collections.map.LRUMap.updateEntry(LRUMap.java:217)

Line is:

            entry.before.after = entry.after;

Which, looking at the code, implies that entry.before is null. Maybe another place to put a state check?

Maybe a state check would be worth it there too?",19/Mar/08 06:50;bayard;TODO: Add the two state checks. Close as Cannot Reproduce.,"02/Apr/08 06:04;bayard;svn ci -m ""Adding a state check as per COLLECTIONS-3. I got an NPE when running through tests without synchronization"" src

Sending        src/java/org/apache/commons/collections/map/LRUMap.java
Transmitting file data .
Committed revision 643755.",02/Apr/08 06:05;bayard;Everything points to this being synchronization issues.,"17/Jun/09 09:29;joehni;Reopened, added a unit test (currently not executed, marked with TODO) that reproduces the ConcurrentModificationException. Happens only if the remove is called on the iterator from the keySet. Works fine for the iterators from the entrySet and values. See improved unit test TestLRUMap.","17/Jun/09 09:48;joehni;Closed again as ""Cannot reproduce"". I will open a new issue for the ConcurrentModificationException. This issue's history with different reported problems is simply too vague."
IteratorChain skips over elements in iterator,COLLECTIONS-111,12342870,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Cannot Reproduce,,jo@jogiles.co.nz,jo@jogiles.co.nz,21/Jan/06 10:12,28/Feb/13 19:52,10/Jun/19 03:21,19/Mar/08 06:52,3.1,,,,,,,Iterator,,,0,,,,"Hi there,
When using the IteratorChain class to add multiple iterators, it appears that
using itChain.hasNext() and itChain.next() skips a number of elements in the
iterator at each step.

Given a single iterator of 7 elements, and using the following code:

private IteratorChain buildIterator() {
// this iterator contains the children of the current object only
Iterator it = getChildren(p);
		
// we use an IteratorChain to add multiple iterators together without the
overhead of copying
IteratorChain itChain = new IteratorChain(it);

return itChain;
}

and then simply
IteratorChain it = treeModel.getAllTreeNodes(obj);
	
// FIXME this only prints one or two of the results, which is a bug!
while (it.hasNext())
    System.out.println("": "" + it.next().getClass());

I put in 7 elements, but only get 2 out - the 2nd and the last elements. It
appears that through my debugging that the nextClause variable is updated even
when the hasNext() function is called.

Also, if I put 7 system.out.println statements, all elements are printed as normal.","Operating System: Windows XP
Platform: PC",,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,38341.0,,,2006-01-21 10:52:04.0,,,false,,,,,,,,,,,,,,18887,,,Wed Mar 19 06:52:30 UTC 2008,,,,,,0|i0sj9b:,164597,,,,,,,,,"21/Jan/06 10:24;jo@jogiles.co.nz;As an update, I have just downloaded and tried using Collections 2.1.1 - that
works as expected. I will investigate the differences and try to post a patch.","21/Jan/06 10:34;jo@jogiles.co.nz;(In reply to comment #0)
Replacing the updateCurrentIterator() method from the 3.1 package with the one
from 2.1 fixes this bug. Can someone investigate whether this is possible and
let me know?",21/Jan/06 10:52;scolebourne@joda.org;Can you build a test case to demonstrate the problem? Thanks,"21/Jan/06 11:05;jo@jogiles.co.nz;(In reply to comment #3)
Hi there - I have tried - and I can't reproduce it outside of my environment.
But as I say, I now have two snapshots in my system, and I replace the method in
3.1 with the one from 2.1, it works exactly as expected.

However, doing so causes the current test cases to fail in two areas:
testFurstIteratorIsEmptyBug()
testEmptyChain()

My simple test case works under both 3.1 or 2.1.1 however. It is:
    public void testSize() {
    	// we know that the size is 6 elements, so lets ensure that is correct
    	Iterator iter = makeFullIterator();
    	int i = 0;
    	while (iter.hasNext()) {
    		++i;
    		iter.next();
    	}
    	
    	assertEquals(6, i);
    }","26/Jan/06 09:37;scolebourne@joda.org;There have been changes to the method updateCurrentIterator() between these
versions that we need, so we can't just reverse the change. I'd love to fix any
bug that can be identified cleanly. For now though I'm placing this in NEEDINFO
awaiting a test case.",19/Jul/06 21:55;scolebourne;Still awaiting a test case against 3.2,15/Aug/07 05:30;bayard;If it's a bug that couldn't be recreated outside a particular environment... I'm suspicious that it's a threading issue.,"11/Sep/07 17:35;bayard;Here's the 2.1.1 to trunk diff for that method:

{code:java}
     protected void updateCurrentIterator() {
         if (currentIterator == null) {
-            currentIterator = (Iterator) iteratorChain.get(0);
+            if (iteratorChain.isEmpty()) {
+                currentIterator = EmptyIterator.INSTANCE;
+            } else {
+                currentIterator = (Iterator) iteratorChain.get(0);
+            }
             // set last used iterator here, in case the user calls remove
             // before calling hasNext() or next() (although they shouldn't)
             lastUsedIterator = currentIterator;
-            return;
         }

-        if (currentIteratorIndex == (iteratorChain.size() - 1)) {
-            return;
-        }
-
-        while (currentIterator.hasNext() == false) {
-            ++currentIteratorIndex;
+        while (currentIterator.hasNext() == false && currentIteratorIndex < iteratorChain.size() - 1) {
+            currentIteratorIndex++;
             currentIterator = (Iterator) iteratorChain.get(currentIteratorIndex);
-
-            if (currentIteratorIndex == (iteratorChain.size() - 1)) {
-                return;
-            }
         }
     }
{code}","11/Sep/07 17:56;bayard;The first block of code is a bit of protection that stops an IndexOutOfBoundsException. It's not possible to enter updateIteratorChain() without lockChain() having been called, so it's not possible for the iterator to be empty and then get values later. This initial bit of code looks good.

Then a return statement is removed. With the return statement, an empty iterator would be considered to be full, so removing this return statement makes sense. It does mean that there's a new code path to go through the first time. Jonathan does report that the first element doesn't return, which might point to this return statement; but he also reports other later elements are missing which doesn't. 

The following changes are one change. An if statement is rolled into the while loop below it. It's the biggest change, but it seems to be fine. 

The new code path means that:

a) An empty iterator is passed down to the while loop. Its hasNext() is false and currentIteratorIndex (=0) is not less than size-1 (=-1). So the while loop is not entered and the method returns as before.

b) The first iterator in the array is at its beginning. In Jonthan's case its hasNext is true, and currentIteratorIndex (=0) is not less than size-1 (0). The while loop is not entered and the method returns as before. The alternative to Jonathan's case would be an empty iterator, but that would also not enter the while loop due to the second clause.

So none of the code changes would appear to cause any problems, and things would appear to be thread safe because they are read-only at that time - unless more than one thing is reading the iterator.

That's the only explanation I can see - that there was another thread that was sometimes reading the other iterator. It doesn't match to Jonathan's report of 2.1.1 being fine and 3.1 being bad.

I've been looking at trunk and not 3.1. Looking at the diff between 3.1 and trunk, the only change has been protection in remove() against calling updateCurrentIterator() unless the currentIterator is null. As the report only has the one iterator in the chain, I can't see this bug leading to elements vanishing. updateIteratorChain doesn't do element moving, just iterators.

So... I'm all for closing this as Cannot Reproduce. ","19/Mar/08 06:52;bayard;As per my previous investigation, closing this as Cannot Reproduce.",,,,,,,,,,,,,,,,,,,,
[collection] Map filter with MapUtils.predicatedMap feature request,COLLECTIONS-88,12342188,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Won't Fix,,luc.carpentier@uniway.be,luc.carpentier@uniway.be,14/Apr/05 15:32,03/May/11 00:36,10/Jun/19 03:21,15/Mar/08 21:36,3.1,,,,,,,,,,0,,,,"Hello,

I stumbled into the following problem:

A client submits an http request with prefixed parameters. Each prefix will 
have it's own javabean to populate. So if there are two prefixes, then there 
will be two different javabeans to populate from the request parameters.

I created a PrefixPredicate that only allows values with a specific prefix. I 
then used this PrefixPredicate to copy the Map with the request parameters to 
a predicated Map with:

Map predicatedMap = MapUtils.predicatedMap(dataMap,keyPredicate,null);

However, since the request parameters contain parameters with other prefixes 
as well, this returns an IllegalArgumentException.

It would be nice to be able to specify to the MapUtils.predicatedMap method to 
ignore entries that do not comply to the predicate instead of to throw an 
exception.

There are lots of possabilities to filter on a Collection, but a Map is not a 
collection...","Operating System: other
Platform: Other",,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,34446.0,,,2005-05-23 03:04:52.0,,,false,,,,,,,,,,,,,,18910,,,Tue May 03 00:36:57 UTC 2011,,,,,,0|i0sjef:,164620,,,,,,,,,"23/May/05 03:04;scolebourne@joda.org;The solution to your problem would appear to be:

Map reqParams;
CollectionUtils.filter(reqParams.keySet(), filterPredicate);


The deeper request in this call is covered by the proposal to add FilteredMap to
[collections].

Closing this call as wontfix.","03/May/11 00:25;anirudhvyas;I don't buy that argument, I can submit the patch if thats what it takes, I still feel this is a valid issue, and the method should be called filter( ) on MapUtils, that solution being described is ugly. My 2 cents.

Anirudh","03/May/11 00:36;anirudhvyas;I would like to commit this feature if permitted, please provide me with the instructions, your formatting standards etc link and I'll be happy to help you guys out.",,,,,,,,,,,,,,,,,,,,,,,,,,,
"CollectionUtils.removeAll(Collection collection, Collection remove) calls ListUtils.retainAll(collection, remove)",COLLECTIONS-358,12468204,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Duplicate,,rasenderhase,rasenderhase,29/Jun/10 21:35,29/Jun/10 23:38,10/Jun/19 03:21,29/Jun/10 23:38,3.1,,,,,,,Collection,,,0,,,,"Inside CollectionUtils.removeAll(Collection collection, Collection remove) the retainAll() method of ListUtils is called in line 1122.
It should read ListUtils.removeAll(collection, remove) instead.

Workaround: use ListUtils.removeAll(Collection collection, Collection remove) instead.",any,,,,,,,,,COLLECTIONS-357,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,18645,,,2010-06-29 21:35:09.0,,,,,,0|i0shz3:,164389,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections][PATCH] SetUniqueList breaks when swapping entries,COLLECTIONS-124,12342021,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,thomas.dunham@reuters.com,thomas.dunham@reuters.com,29/Jan/05 04:15,15/Mar/08 21:36,10/Jun/19 03:21,15/Mar/08 21:36,3.1,,,,,,,,,,0,,,,"If you create a SetUniqueList with two entries a and b:
[a,b]
Then you do:
Object a = l.get(0);
l.set(0, b)
l.add(0, a);
You expect to have swapped the two entries. But you get
[b]
Which seems to be wrong.","Operating System: All
Platform: PC",,,,,,,,,,,,29/Jan/05 04:34;thomas.dunham@reuters.com;ASF.LICENSE.NOT.GRANTED--code.patch;https://issues.apache.org/jira/secure/attachment/12333369/ASF.LICENSE.NOT.GRANTED--code.patch,29/Jan/05 04:18;thomas.dunham@reuters.com;ASF.LICENSE.NOT.GRANTED--setUniqBug.txt;https://issues.apache.org/jira/secure/attachment/12333367/ASF.LICENSE.NOT.GRANTED--setUniqBug.txt,29/Jan/05 04:34;thomas.dunham@reuters.com;ASF.LICENSE.NOT.GRANTED--test.patch;https://issues.apache.org/jira/secure/attachment/12333368/ASF.LICENSE.NOT.GRANTED--test.patch,3.0,,,,,,,,,,,,,,,,33294.0,,,2005-02-04 09:13:50.0,,,false,,,,,,,,,,,,,,18874,,,Fri Feb 04 09:13:50 UTC 2005,,,,,,0|i0sj6f:,164584,,,,,,,,,"29/Jan/05 04:18;thomas.dunham@reuters.com;Created an attachment (id=14128)
This TestCase shows the problem from outwith the packages.
","29/Jan/05 04:34;thomas.dunham@reuters.com;Created an attachment (id=14129)
This patch to TestSetUniqueList exposes the bug.
","29/Jan/05 04:34;thomas.dunham@reuters.com;Created an attachment (id=14130)
This patch to SetUniqueList passes the tests
","04/Feb/05 09:13;scolebourne@joda.org;Patches applied, thanks",,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] StaticBucketMap#containsKey(final Object key) can return illegal value.,COLLECTIONS-123,12342724,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,ujihara@aurora.dti.ne.jp,ujihara@aurora.dti.ne.jp,20/Nov/05 18:18,15/Mar/08 21:36,10/Jun/19 03:21,15/Mar/08 21:36,3.1,,,,,,,,,,0,,,,"org.apache.commons.collections.map.StaticBucketMap#containsKey(""any string"") 
can return true by mistake when null key is containing in buckets.
I think containsKey(Object) method has to be modified like the following.

    public boolean containsKey(final Object key) {
        int hash = getHash(key);

        synchronized (locks[hash]) {
            Node n = buckets[hash];

            while (n != null) {
-                if (n.key == null || (n.key != null && n.key.equals(key))) {
+                if ((n.key == null && key == null) || (n.key != null && 
n.key.equals(key))) {
                    return true;
                }

                n = n.next;
            }
        }
        return false;
    }

Kazuya Ujihara","Operating System: Windows XP
Platform: All",,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,37567.0,,,2005-11-23 07:28:49.0,,,false,,,,,,,,,,,,,,18875,,,Wed Nov 23 07:28:49 UTC 2005,,,,,,0|i0sj6n:,164585,,,,,,,,,23/Nov/05 07:28;scolebourne@joda.org;Thanks for the bug report and fix. Applied on SVN.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] Error in deserialization of full BoundedFifoBuffer,COLLECTIONS-134,12342722,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Duplicate,,apachebugz@tkuhn.de,apachebugz@tkuhn.de,17/Nov/05 07:52,15/Mar/08 21:36,10/Jun/19 03:21,15/Mar/08 21:36,3.1,,,,,,,,,,0,,,,"If a BoundedFifoBuffer is serialized and then deserialized the value of the end
attribute is set to the max size of the Buffer which is a fault and causes an
ArrayIndexOutOfBoundException during add(object). In this case the value of end
must be set to 0 in the deserialization.","Operating System: All
Platform: All",,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,37539.0,,,2005-11-22 08:43:45.0,,,false,,,,,,,,,,,,,,18864,,,Tue Nov 22 08:43:45 UTC 2005,,,,,,0|i0sj47:,164574,,,,,,,,,"17/Nov/05 08:11;apachebugz@tkuhn.de;Actually the exception thrown is not an ArrayIndexOutOfBoundsException as statet
in my report but an BufferOverflowException as expected. The problem with the
faulty ArrayIndexOutOfBoundsException occours if you first call remove() and
then add(object) on the deserialized Buffer. (I never used BoundedFifoBuffer by
itself but had the problem with a CircularFifoBuffer wich first calls a remove()
on the full Buffer during add.)","22/Nov/05 08:43;scolebourne@joda.org;

*** This bug has been marked as a duplicate of 31433 ***",,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] CircularFifoBuffer not really Serializable,COLLECTIONS-122,12341754,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,kalle.gustafsson@compingo.se,kalle.gustafsson@compingo.se,27/Sep/04 14:24,15/Mar/08 21:36,10/Jun/19 03:21,15/Mar/08 21:36,3.1,,,,,3.2,,,,,0,,,,"Create a CircularFifoBuffer of size N. Serialize and deserialize a couple of
times. When adding element N+1, an error occurs. (OutOfMemoryError in our
testing environment, ArrayIndexOutOfBounds when running the code snippet.)

The error can be reproduced by running the following code snippet in a scrapbook
page in WebSphere Studio 5.1.2 (default JRE) on Windows XP (The error occurs at
the third add operation):

org.apache.commons.collections.buffer.CircularFifoBuffer b = new
org.apache.commons.collections.buffer.CircularFifoBuffer(2);

b.add(""a"");

java.io.ByteArrayOutputStream bos = new java.io.ByteArrayOutputStream();
new java.io.ObjectOutputStream(bos).writeObject(b);

org.apache.commons.collections.buffer.CircularFifoBuffer b2 =
(org.apache.commons.collections.buffer.CircularFifoBuffer) new
java.io.ObjectInputStream(new
java.io.ByteArrayInputStream(bos.toByteArray())).readObject();

b2.add(""b"");

bos = new java.io.ByteArrayOutputStream();
new java.io.ObjectOutputStream(bos).writeObject(b2);

b = (org.apache.commons.collections.buffer.CircularFifoBuffer) new
java.io.ObjectInputStream(new
java.io.ByteArrayInputStream(bos.toByteArray())).readObject();

b.add(""c"");

bos = new java.io.ByteArrayOutputStream();
new java.io.ObjectOutputStream(bos).writeObject(b);

b2 = (org.apache.commons.collections.buffer.CircularFifoBuffer) new
java.io.ObjectInputStream(new
java.io.ByteArrayInputStream(bos.toByteArray())).readObject();","Operating System: Solaris
Platform: Sun",,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,31433.0,,,2004-10-17 05:26:53.0,,,false,,,,,,,,,,,,,,18876,,,Tue Nov 22 08:43:46 UTC 2005,,,,,,0|i0sj6v:,164586,,,,,,,,,"17/Oct/04 05:26;scolebourne@joda.org;Thanks for this bug report.

This problem only occurs when serializing a full BoundedFifoBuffer or 
CircularFifoBuffer. CVS is now fixed.",22/Nov/05 08:43;scolebourne@joda.org;*** COM-2570 has been marked as a duplicate of this bug. ***,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] AbstractMapBag.BagIterator.remove broken,COLLECTIONS-107,12342373,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,scolebourne@joda.org,scolebourne@joda.org,15/Jul/05 08:07,15/Mar/08 21:36,10/Jun/19 03:21,15/Mar/08 21:36,3.1,,,,,,,,,,0,,,,"I can't get in to CVS to see if this is fixed, but there is a bug in 
AbstractMapBag in 3.1: BagIterator.remove() does not properly remove the 
last instance of a given item; the result is infinite looping.  Here is a 
patch.

-steve

Steve Clark
ECOS Development Group
steve_clark@fws.gov
(970)226-9291


--- AbstractMapBag.java.orig    2005-07-14 11:14:33.708373173 -0600
+++ AbstractMapBag.java 2005-07-14 11:15:30.566623793 -0600
@@ -221,7 +221,7 @@
                 throw new IllegalStateException();
             }
             MutableInteger mut = (MutableInteger) current.getValue();
-            if (mut.value > 0) {
+            if (mut.value > 1) {
                 mut.value--;
                 parent.size--;
             } else {","Operating System: All
Platform: All",,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,35747.0,,,,,,false,,,,,,,,,,,,,,18891,,,Fri Jul 15 08:12:10 UTC 2005,,,,,,0|i0sja7:,164601,,,,,,,,,"15/Jul/05 08:12;scolebourne@joda.org;The proposed patch fixed half the problem.

Full fix and test case committed in svn r219131.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] CursorableLinkedList iteration broken with previous,COLLECTIONS-101,12342378,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,scolebourne@joda.org,scolebourne@joda.org,16/Jul/05 23:14,15/Mar/08 21:36,10/Jun/19 03:21,15/Mar/08 21:36,3.1,,,,,,,,,,0,,,,"With a CursorableLinkedList, if you perform a Next, Next, Previous on an
iterator/cursor, then remove the last object returned by index from the list,
you will leave the cursor in an invalid state.

You should at this point not be able to call remove/set on the iterator, but you
can.","Operating System: All
Platform: All",,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,35766.0,,,,,,false,,,,,,,,,,,,,,18897,,,Sat Jul 16 23:20:50 UTC 2005,,,,,,0|i0sjbj:,164607,,,,,,,,,16/Jul/05 23:20;scolebourne@joda.org;Fixed in svn rv219330,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] When the AbstractHashedMap is serialized and deserialized the data array doubles its size,COLLECTIONS-93,12342150,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,mcesar@hmsolucoes.com.br,mcesar@hmsolucoes.com.br,02/Apr/05 03:19,15/Mar/08 21:36,10/Jun/19 03:21,14/Jul/06 12:04,3.1,,,,,,,,,,1,,,,"In the method ""AbstractHashMap#doReadObject"", the method call ""threshold =
calculateThreshold(data.length, loadFactor);"" is after the ""put(key, value);"".
The ""put"" method uses the threshold to check the capacity of the data array.
In this checking, the threshold is zero, leading to a resize of the data array.
At each serialization/deserialization the size of the data array doubles.","Operating System: Windows XP
Platform: PC",,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,34265.0,,,2005-05-08 03:05:25.0,,,false,,,,,,,,,,,,,,18905,,,Fri Jul 14 12:04:24 UTC 2006,,,,,,0|i0sjdb:,164615,,,,,,,,,08/May/05 03:05;scolebourne@joda.org;Change made in SVN revision 169102,14/Jul/06 12:04;bayard;Reopen/reclose to deal with migration bug.,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] Only last element is removeable when CircularFifoBuffer is full,COLLECTIONS-104,12341996,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,amir@mathforum.org,amir@mathforum.org,13/Jan/05 03:30,15/Mar/08 21:36,10/Jun/19 03:21,15/Mar/08 21:36,3.1,,,,,,,,,,0,,,,"If the circular fifo buffer is full and you remove an item, that is not the last
one, it breaks.

code example:

import java.io.*;
import org.apache.commons.collections.buffer.*;

class Stub {
    public static void main(String[] args) {
        CircularFifoBuffer fifo = new CircularFifoBuffer(5);
        System.out.println(fifo);

        fifo.add(new String(""1""));
        System.out.println(fifo);

        fifo.add(new String(""2""));
        System.out.println(fifo);

        fifo.add(new String(""3""));
        System.out.println(fifo);

        fifo.add(new String(""4""));
        System.out.println(fifo);

        System.out.println(""adding 5"");
        fifo.add(new String(""5""));
        System.out.println(fifo);

        String six = new String(""6"");
        System.out.println(""adding 6"");
        fifo.add(six);
        System.out.println(fifo);

/* uncomment the following block to avoid problem
        System.out.println(""fifo.isFull?:""+fifo.isFull());
        System.out.println(""removing 6"");
        fifo.remove(new String(""6""));
        System.out.println(fifo);
*/

        System.out.println(""fifo.isFull?:""+fifo.isFull());

        System.out.println(""removing 3"");
        fifo.remove(new String(""3""));
        System.out.println(fifo);

        System.out.println(""removing 4"");
        fifo.remove(new String(""4""));
        System.out.println(fifo);

        System.out.println(""clearing"");
        fifo.clear();
        System.out.println(""removing 4"");
        fifo.remove(new String(""4""));
        System.out.println(fifo);

    }
}



==============

output busted:

[]
[1]
[1, 2]
[1, 2, 3]
[1, 2, 3, 4]
adding 5
[1, 2, 3, 4, 5]
adding 6
[2, 3, 4, 5, 6]
fifo.isFull?:true
removing 3
Exception in thread ""main"" java.lang.ArrayIndexOutOfBoundsException: -1
        at
org.apache.commons.collections.buffer.BoundedFifoBuffer$1.remove(BoundedFifoBuffer.java:347)
        at java.util.AbstractCollection.remove(AbstractCollection.java:255)
        at Stub.main(Stub.java:40)","Operating System: Linux
Platform: PC",,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,33071.0,,,2005-01-14 23:16:38.0,,,false,,,,,,,,,,,,,,18894,,,Thu Feb 09 01:05:37 UTC 2006,,,,,,0|i0sjav:,164604,,,,,,,,,"13/Jan/05 06:12;amir@mathforum.org;It seems like I incorrectly stated the problem.

It turns out the error can happen when the buffer is not full also.

My new theory is that you can only remove an item from a non-boundary position
if there has not been a shift (shift=adding N+1 items to a buffer of size N).

In these examples the buffer is not full when the remove(object) is called.
As you can see the size of the buffer remains the same (6) however in the second
example a 7th item is added which causes a shift.

[]
[1]
[1, 2]
[1, 2, 3]
[1, 2, 3, 4]
adding 5
[1, 2, 3, 4, 5]
adding 6
[1, 2, 3, 4, 5, 6]
removing
[2, 3, 4, 5, 6]
fifo.isFull?:false
removing 4
[2, 3, 5, 6]
removing 4
[2, 3, 5, 6]

=======

[]
[1]
[1, 2]
[1, 2, 3]
[1, 2, 3, 4]
adding 5
[1, 2, 3, 4, 5]
adding 6
[1, 2, 3, 4, 5, 6]
adding 7
[2, 3, 4, 5, 6, 7]
removing
[3, 4, 5, 6, 7]
fifo.isFull?:false
removing 4
Exception in thread ""main"" java.lang.ArrayIndexOutOfBoundsException: -1
        at
org.apache.commons.collections.buffer.BoundedFifoBuffer$1.remove(BoundedFifoBuffer.java:347)
        at java.util.AbstractCollection.remove(AbstractCollection.java:255)
        at Stub.main(Stub.java:51)


Thanks,
Amir","14/Jan/05 23:16;phil@steitz.com;Thank you for reporting this.  Looks like the problem is in BoundedFifoBuffer. 
IIUC how this field is supposed to be maintained, the end field is not being
updated correctly. ","16/Jan/05 07:52;phil@steitz.com;The problem was in BoundedFifoBuffer's iterator.remove method.  The shift
operation was not correctly incrementing / decrementing array indexes.  Changes
have been committed to fix this. Should be fixed in the nightly build starting
1/15/05.",09/Feb/06 01:05;gudnabrsam@yahoo.com;*** COM-2741 has been marked as a duplicate of this bug. ***,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] TreeList Collections.binarySearch problem - general remove() after previous() problem,COLLECTIONS-70,12342290,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,trim@atlas.cz,trim@atlas.cz,08/Jun/05 06:21,15/Mar/08 21:36,10/Jun/19 03:21,15/Mar/08 21:36,3.1,,,,,,,,,,0,,,,"Sometimes TreeList crashes if i tried to call:
  Collections.binarySearch(queue, n, comp);
with ArrayList is everything ok.

Exception in thread ""main"" java.lang.NullPointerException
	at 
org.apache.commons.collections.list.TreeList$TreeListIterator.previous
(TreeList.java:841)
	at java.util.Collections.get(Unknown Source)
	at java.util.Collections.iteratorBinarySearch(Unknown Source)
	at java.util.Collections.binarySearch(Unknown Source)
	at utils.queue.QueueSorted.put(QueueSorted.java:51)
	at framework.search.GraphSearch.solve(GraphSearch.java:53)
	at search.informed.BestFirstSearch.solve(BestFirstSearch.java:20)
	at Hlavni.main(Hlavni.java:66)","Operating System: Windows XP
Platform: Other",,,,,,,,,,,,09/Dec/05 07:58;trim@atlas.cz;ASF.LICENSE.NOT.GRANTED--Test.java;https://issues.apache.org/jira/secure/attachment/12333547/ASF.LICENSE.NOT.GRANTED--Test.java,09/Dec/05 07:30;trim@atlas.cz;ASF.LICENSE.NOT.GRANTED--Test.java;https://issues.apache.org/jira/secure/attachment/12333546/ASF.LICENSE.NOT.GRANTED--Test.java,11/Dec/05 21:45;trim@atlas.cz;ASF.LICENSE.NOT.GRANTED--TestCaseForBug35258.java;https://issues.apache.org/jira/secure/attachment/12333548/ASF.LICENSE.NOT.GRANTED--TestCaseForBug35258.java,3.0,,,,,,,,,,,,,,,,35258.0,,,2005-07-09 10:37:53.0,,,false,,,,,,,,,,,,,,18928,,,Sat Jan 21 10:50:10 UTC 2006,,,,,,0|i0sjif:,164638,,,,,,,,,09/Jul/05 10:37;jwcarman;Do you have a test case for this? ,"17/Jul/05 02:10;scolebourne@joda.org;This report lead me to examine the previous() method, and it was broken in
various classes when remove() is used afterwards.

Changes in svn rv219343","09/Dec/05 07:30;trim@atlas.cz;Created an attachment (id=17185)
TestSuite
","09/Dec/05 07:37;trim@atlas.cz;I posted a test case for a bug. It seems as previous() metod is unstable after 
remove(o);

This test failed after something about 6-15 cycles of 
       	int i = Collections.binarySearch(pq, n);
        pq.remove(n);

","09/Dec/05 07:39;jwcarman;We can't use the test case as-is, since it uses JDK5 features, but we'll
retrofit it.  Does this test fail repeatedly at the same point?  ","09/Dec/05 07:58;trim@atlas.cz;Created an attachment (id=17186)
TestSuite for java 1.4
","09/Dec/05 08:05;trim@atlas.cz;The test not fail repeatedly at the same point, because there is shuffed 
ArrayList which is romoving from TreeList.
If TreeList is in same order as List which we are removing, than there is no 
error reported.","09/Dec/05 19:06;jwcarman;Why don't you try passing in a Random instance to the Collections.shuffle()
method?  You could seed it with a known value that fails every time.  You could do:

Collections.shuffle( noes, new Random( 1 ) );

That way, it would be more deterministic.","11/Dec/05 21:45;trim@atlas.cz;Created an attachment (id=17194)
Test case for  a COM-2138 version 2.0

It was a good idea to use seeded random generator for Collections.shuffle(). So
i was able to find much more suitable test case. This test case has TreeList
size only 5 nodes and the point of inconsistece of listIterator is known too.
It can be much more easy to solve that bug with this test case than with
previous one.
","21/Jan/06 10:50;scolebourne@joda.org;As always, a good test case makes all the difference.

Fixed in SVN 370952",,,,,,,,,,,,,,,,,,,,
[collections] java.lang.ArrayIndexOutOfBoundsException,COLLECTIONS-72,12342893,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Duplicate,,stijn.christiaens@vub.ac.be,stijn.christiaens@vub.ac.be,08/Feb/06 20:03,15/Mar/08 21:36,10/Jun/19 03:21,15/Mar/08 21:36,3.1,,,,,,,,,,0,,,,"In BoundedFifoBuffer (line 340):

                // Other elements require us to shift the subsequent elements

                int i = lastReturnedIndex + 1;

                while (i != end) {

                    if (i >= maxElements) {

                        elements[i - 1] = elements[0];

                        i = 0;

                    } else {

                        elements[i - 1] = elements[i];

                        i++;

                    }

                }
An AIOOBException is thrown at line 347 when trying to remove an element and i = 0.","Operating System: other
Platform: Other",,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,38565.0,,,2006-02-08 23:21:43.0,,,false,,,,,,,,,,,,,,18926,,,Thu Feb 09 01:08:26 UTC 2006,,,,,,0|i0sjhz:,164636,,,,,,,,,"08/Feb/06 23:21;gudnabrsam@yahoo.com;Looking at the code I don't immediately see how this is possible.  Can you
attach a testcase (simple main() harness or whatever) that reproduces the problem?","08/Feb/06 23:31;stijn.christiaens@vub.ac.be;This is the code that caused the bug. The variable breadCrumbs is a
BoundedFifoBuffer, but we use the Collection interface.
The target is to run over the buffer. If we encounter an element equal to the
one we have, all next elements in the buffer must be removed.
The Exception happens when the first element in the collection is the element we
have, so all the remaining ones must be removed, and only the first can stay.
The exception happens at the call of iter.remove()

		// see if this crumb is already present, because if it is
		// we must remove all later ones for a natural feel
		// breadCrumbs is a BoundedFifoBuffer, but we use the interface Collection
		boolean remove = false;
		Iterator<BreadCrumb> iter = breadCrumbs.iterator();
		while (iter.hasNext()) {
			BreadCrumb tempCrumb = iter.next();
			if (remove) {
				iter.remove();
			}
			if (crumb.equals(tempCrumb)) {
				remove = true;
			}
		}","08/Feb/06 23:54;gudnabrsam@yahoo.com;Silly question: are you using org.apache.commons.collections.BoundedFifoBuffer
or org.apache.commons.collections.buffer.BoundedFifoBuffer?  Based on the code
you provided in the beginning, the former?  Maybe you should try the latter.","09/Feb/06 00:11;stijn.christiaens@vub.ac.be;Actually I am using a CircularFifoBuffer in my class, which extends the
...collections.buffer.BoundedFifoBuffer.","09/Feb/06 00:41;stijn.christiaens@vub.ac.be;This little class recreates the bug. It must have something to do with the
automatic remove (which increases the member attribute start), because if there
is no overflow (and thus automatic remove) the problem does not occur. I hope
this helps.

import java.util.Collection;
import java.util.Iterator;

import org.apache.commons.collections.buffer.CircularFifoBuffer;

public class Test {

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		Collection<String> breadCrumbs = new CircularFifoBuffer(4);
		breadCrumbs.add(""1"");
		breadCrumbs.add(""2"");
		breadCrumbs.add(""3"");
		breadCrumbs.add(""4"");
		breadCrumbs.add(""5"");
		
		String current = ""2"";

		Iterator<String> iter = breadCrumbs.iterator();
		boolean remove = false;
		while (iter.hasNext()) {
			String temp = iter.next();
			if (remove) {
				iter.remove();
			}
			if (current.equals(temp)) {
				remove = true;
			}
		}
		if (!remove) {
			breadCrumbs.add(current);
		}
		
		iter = breadCrumbs.iterator();
		while (iter.hasNext()) {
			String temp = iter.next();
			System.out.println(temp);
		}		
	}

}
","09/Feb/06 01:03;gudnabrsam@yahoo.com;I can recreate w/ 3.1 but not with SVN HEAD; therefore the bug has already been
fixed.","09/Feb/06 01:05;gudnabrsam@yahoo.com;Looks like a duplicate of COM-1844.

*** This bug has been marked as a duplicate of 33071 ***",09/Feb/06 01:08;stijn.christiaens@vub.ac.be;Ok. Thanks for the swift assistance!,,,,,,,,,,,,,,,,,,,,,,
[collections] IteratorChain.remove() in combination with FilterIterator,COLLECTIONS-77,12342151,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,peter@clueless.be,peter@clueless.be,02/Apr/05 03:52,15/Mar/08 21:36,10/Jun/19 03:21,15/Mar/08 21:36,3.1,,,,,,,,,,0,,,,"IteratorChain.remove() throws IllegalStateException when one of the underlying
iterators is a FilterIterator

code:
http://nagoya.apache.org/eyebrowse/ReadMsg?listName=commons-dev@jakarta.apache.org&msgNo=64950","Operating System: Windows XP
Platform: Other",,,,,,,,,,,,03/Apr/05 05:18;jwcarman;ASF.LICENSE.NOT.GRANTED--34267 .patch;https://issues.apache.org/jira/secure/attachment/12333439/ASF.LICENSE.NOT.GRANTED--34267+.patch,02/Apr/05 03:53;peter@clueless.be;ASF.LICENSE.NOT.GRANTED--Main.java;https://issues.apache.org/jira/secure/attachment/12333438/ASF.LICENSE.NOT.GRANTED--Main.java,,2.0,,,,,,,,,,,,,,,,34267.0,,,2005-04-03 05:18:38.0,,,false,,,,,,,,,,,,,,18921,,,Tue May 17 20:57:21 UTC 2005,,,,,,0|i0sjgv:,164631,,,,,,,,,"02/Apr/05 03:53;peter@clueless.be;Created an attachment (id=14607)
example
","03/Apr/05 05:18;jwcarman;Created an attachment (id=14610)
Here's a patch.

Here's a patch (with test case) which fixes the problem and doesn't break any
of the other test cases (at least not in collections).	Since I'm relatively
new to the project as a committer, I didn't want to go ahead and commit this
stuff until one of the experts checks it out.","16/May/05 01:59;scolebourne@joda.org;If it fixes it, I suggest you commit it.

However, the patch does have rather a lot of stylistic fixes which should be
made in a separate commit, if at all.","17/May/05 06:21;peter@clueless.be;(In reply to comment #3)
> If it fixes it, I suggest you commit it.
> 
> However, the patch does have rather a lot of stylistic fixes which should be
> made in a separate commit, if at all.

The fix worked. Since I myself did not create the patch/fix, but James Carman
did, I suggest James commits it.","17/May/05 20:39;jwcarman;I would have committed it a while ago, but I don't remember my password.  I used
to use SSH to remember my password when using CVS.  I have to figure out how to
have my password reset.","17/May/05 20:57;jwcarman;I checked it in.  Didn't see that little bit about svnpasswd on the FAQ site. 
Guess it boiled down to RTFM.",,,,,,,,,,,,,,,,,,,,,,,,
TreeList with inproved iterator() and listIterator() implementation,COLLECTIONS-84,12341192,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,js@ekkono.com,js@ekkono.com,12/May/04 23:08,15/Mar/08 21:36,10/Jun/19 03:21,15/Mar/08 21:36,3.1,,,,,,,,,,0,,,,"Added references to next and and prev using a flag.  This is called Faedelung in
German :-)","Operating System: other
Platform: Other",,,,,,,,,,,,12/May/04 23:11;js@ekkono.com;ASF.LICENSE.NOT.GRANTED--TreeList.java;https://issues.apache.org/jira/secure/attachment/12332686/ASF.LICENSE.NOT.GRANTED--TreeList.java,12/May/04 23:09;js@ekkono.com;ASF.LICENSE.NOT.GRANTED--TreeList.java;https://issues.apache.org/jira/secure/attachment/12332685/ASF.LICENSE.NOT.GRANTED--TreeList.java,,2.0,,,,,,,,,,,,,,,,28930.0,,,2004-05-13 06:19:41.0,,,false,,,,,,,,,,,,,,18914,,,Thu May 13 06:19:41 UTC 2004,,,,,,0|i0sjfb:,164624,,,,,,,,,"12/May/04 23:09;js@ekkono.com;Created an attachment (id=11523)
Source ofnew version
","12/May/04 23:11;js@ekkono.com;Created an attachment (id=11524)
Forgot to rename _height to height
",13/May/04 06:19;scolebourne@joda.org;Patch applied thanks,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] FilterIterator doesn't reset when properties are set,COLLECTIONS-61,12342823,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,huw12345@hotmail.com,huw12345@hotmail.com,30/Dec/05 05:14,15/Mar/08 21:35,10/Jun/19 03:21,15/Mar/08 21:35,3.1,,,,,,,,,,0,,,,"Test case follows:

[pre]
    /**
     * Test that when the iterator is changed, the hasNext method
     * returns the correct response for the new iterator.
     */
    public void testSetIterator() {
        Iterator iter1 = Collections.singleton(new Object()).iterator();
        Iterator iter2 = Collections.EMPTY_LIST.iterator();
        
        FilterIterator filterIterator = new FilterIterator(iter1);
        filterIterator.setPredicate(TruePredicate.getInstance());
        
        assertTrue(""filterIterator should have an element"", 
filterIterator.hasNext());
        
        filterIterator.setIterator(iter2);
        
        assertTrue(""filterIterator should not have an element"", !
filterIterator.hasNext());
    }

    /**
     * Test that when the predicate is changed, the hasNext method
     * returns the correct response for the new predicate.
     */
    public void testSetPredicate() {
        Iterator iter = Collections.singleton(null).iterator();
        
        FilterIterator filterIterator = new FilterIterator(iter);
        filterIterator.setPredicate(TruePredicate.getInstance());
        
        assertTrue(""filterIterator should have an element"", 
filterIterator.hasNext());
        
        filterIterator.setPredicate(NotNullPredicate.getInstance());
        
        assertTrue(""filterIterator should not have an element"", !
filterIterator.hasNext());
    }
[/pre]","Operating System: other
Platform: Other",,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,38074.0,,,2005-12-30 05:25:30.0,,,false,,,,,,,,,,,,,,18937,,,Sat Jan 07 07:11:26 UTC 2006,,,,,,0|i0sjkf:,164647,,,,,,,,,"30/Dec/05 05:25;jwcarman;Aren't you asserting the opposite of what you want to test?  

assertTrue(""filterIterator should not have an element"", !
filterIterator.hasNext());

Shouldn't this be:

assertFalse(""filterIterator should not have an element"", !
filterIterator.hasNext());","06/Jan/06 08:32;huw12345@hotmail.com;(In reply to comment #1)
> Aren't you asserting the opposite of what you want to test?  

I don't think so.  I admit that I'm living in the past because I'd forgotten 
that JUnit has assertFalse (added about four years ago), but possibly the 
formatting of my code has caused the confusion.  There's a ""!"" hanging at the 
end of the line that means that the test does have the meaning I intend.
","07/Jan/06 07:11;scolebourne@joda.org;Fixed, thanks",,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] UnboundedFifoBuffer deserialization is broken,COLLECTIONS-64,12342377,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,scolebourne@joda.org,scolebourne@joda.org,16/Jul/05 20:24,15/Mar/08 21:35,10/Jun/19 03:21,15/Mar/08 21:35,3.1,,,,,,,,,,0,,,,"The patch should be:

private void readObject(ObjectInputStream in) throws IOException,
ClassNotFoundException {
	in.defaultReadObject();
	int size = in.readInt();
-	buffer = new Object[size];     
+	buffer = new Object[size + 1];     
	for (int i = 0; i < size; i++) {
		buffer[i] = in.readObject();
	}
	head = 0;
	tail = size;
}

Setting tail = size - 1; just caused another bug (ie you couldn't get the last
element in the buffer). This is because tail is supposed to point to the next
unused cell in the buffer array. By creating the buffer to be size + 1, tail
will be set to a valid cell within buffer that is empty (but the cell before it
has an element in it), and the class works properly. 

Thomas Knych, Jordan Krey & Citigroup Analytics Dev team","Operating System: All
Platform: All",,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,35763.0,,,,,,false,,,,,,,,,,,,,,18934,,,Sat Jul 16 20:32:22 UTC 2005,,,,,,0|i0sjjr:,164644,,,,,,,,,"16/Jul/05 20:32;scolebourne@joda.org;This class has an undocumented invariant that the buffer length must be at least
one larger than the size at all times. Comment on invariant added.

Patch applied, thanks.

svn rv219317 and rv219232",,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] Iterator.remove() in UnboundedFifoBuffer does not work,COLLECTIONS-53,12342371,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,schlosser@informatik.tu-darmstadt.de,schlosser@informatik.tu-darmstadt.de,14/Jul/05 18:29,15/Mar/08 21:35,10/Jun/19 03:21,15/Mar/08 21:35,3.1,,,,,,,,,,0,,,,"The implementation of Iterator.remove() in the unbounded fifo buffer is buggy.
It produces an ArrayIndexOutOfBoundExceptions when it needs to swap around the
end of the array to its start.

The code should be:

            public void remove() {
                if (lastReturnedIndex == -1) {
                    throw new IllegalStateException();
                }

                // First element can be removed quickly
                if (lastReturnedIndex == head) {
                    UnboundedFifoBuffer.this.remove();
                    lastReturnedIndex = -1;
                    return;
                }

                // Other elements require us to shift the subsequent elements
                /*
                 * This loop is buggy in the original implementation!
                 */
                int i = lastReturnedIndex + 1;
                while (i != tail) {
                    buffer[decrement(i)] = buffer[i];
                    i = increment(i);
                }

                lastReturnedIndex = -1;
                tail = decrement(tail);
                buffer[tail] = null;
                index = decrement(index);
            }

while the original buggy loop is:

                // Other elements require us to shift the subsequent elements
                int i = lastReturnedIndex + 1;
                while (i != tail) {
                    if (i >= buffer.length) {
                        buffer[i - 1] = buffer[0];
                        i = 0;
                    } else {
                        buffer[i - 1] = buffer[i];
                        i++;
                    }
                }","Operating System: All
Platform: All",,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,35733.0,,,2005-07-15 07:43:31.0,,,false,,,,,,,,,,,,,,18945,,,Sat Jul 16 20:19:10 UTC 2005,,,,,,0|i0sjm7:,164655,,,,,,,,,"15/Jul/05 07:43;scolebourne@joda.org;I cannot find the original code you refer to.

Both versions of UnboundedFifoBuffer are correct in CVS (ie. they match your
fixed code), and neither shows any change in this code since creation.

Have you reported the bug in the right class and right version of [collections]?","15/Jul/05 16:43;schlosser@informatik.tu-darmstadt.de;The source downloadable from the web page:
http://apache.imsam.info/jakarta/commons/collections/source/commons-collections-3.1-src.zip
contains the code I have cited.

Well, but if the code is already fixed in the current CVS it will surely be ok
in the next release of commons collections...","16/Jul/05 20:17;scolebourne@joda.org;Sorry, I misread your original bug report","16/Jul/05 20:19;scolebourne@joda.org;Changes made to SVN rv219316.

BTW, your fix was incomplete, and it demonstrates again the value of having a
test case that shows the bug.",,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] Comparable on AbstractKeyValue,COLLECTIONS-69,12341973,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Won't Fix,,sksingh@synapsistech.com,sksingh@synapsistech.com,03/Jan/05 01:54,15/Mar/08 21:35,10/Jun/19 03:21,15/Mar/08 21:35,3.1,,,,,,,,,,0,,,,"Can either the AbstractKeyValue or DefaultKeyValue implement Comparable. Many a 
times, the KeyValue needs to be sorted on key,value and don't want to have 
screate a new Comparator in order to sort it","Operating System: All
Platform: All",,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,32914.0,,,2005-01-04 09:17:19.0,,,false,,,,,,,,,,,,,,18929,,,Tue Jan 04 09:17:19 UTC 2005,,,,,,0|i0sjin:,164639,,,,,,,,,"04/Jan/05 09:17;scolebourne@joda.org;To make these classes Comparable would imply quite a lot for what would appear
to be an unusual case. In general, implementing additional interfaces in core
classes would be something I would deem a Bad Idea. Instead, the better approach
is to write a smaller, focussed Comparator, even though it seems to be a pain
intially.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] Collection inside Abstract[AnyCollection]Decorator really needed to be transient?,COLLECTIONS-65,12341697,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Cannot Reproduce,,xdury@hotmail.com,xdury@hotmail.com,07/Sep/04 21:42,15/Mar/08 21:35,10/Jun/19 03:21,15/Mar/08 21:35,3.1,,,,,,,,,,0,,,,"Hi,

I would like to know if there was any good reason for all abstract decorator 
classes (like AbstractMapDecorator) to have their decorated collection (map)
transient? It doesn't help when trying to store decorated collections with 
XStream for example... Maybe there's a -really- good reason but I can't see it.

thanks a lot and go on with the good work! :)

Xavier.","Operating System: other
Platform: Other",,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,31091.0,,,2004-09-08 04:01:18.0,,,false,,,,,,,,,,,,,,18933,,,Wed Sep 08 04:01:18 UTC 2004,,,,,,0|i0sjjj:,164643,,,,,,,,,"08/Sep/04 04:01;scolebourne@joda.org;The transient tag is merely a marker to emphasise that the field will not be 
serialized automatically.

Since the Abstract*Decorator classes do not implement the Serializable 
interface themselves, the transient marker actually has no effect. Each 
subclass that IS serializable must manually store the map field using 
readObject/writeObject methods, as per the serialization spec.

The reason behind all of this is to maintain backwards compatability of 
Abstract*Decorator from v3.1 to v3.0, by not forcing all decorators to be 
serializable.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] FastArrayList iterator method throwing ConcurrentModificationException in 'fast' mode,COLLECTIONS-59,12341519,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,cooker123456@yahoo.com,cooker123456@yahoo.com,17/Jun/04 06:55,15/Mar/08 21:35,10/Jun/19 03:21,15/Mar/08 21:35,3.1,,,,,3.2,,,,,0,,,,"Please review the below code, I was under the impression that this not throw an
exception.

 

Thanks,

Rob Cooke.

 

----------------------------

 

 

import org.apache.commons.collections.FastArrayList;

import java.util.Iterator;

 

public class Test2 extends Thread{

  public static void main(String argv[]) throws Exception{

    FastArrayList array=new FastArrayList();

    array.add(""this"");

    array.add(""is"");

    array.add(""a"");

    new Test2(array).start();

    array.setFast(true);

    Thread.sleep(2000);

    array.add(""test"");

  }

  protected FastArrayList array;

  public Test2(FastArrayList array){

    this.array=array;

  }

  public void run(){

    for(Iterator i=array.iterator();i.hasNext();){

      try{Thread.sleep(1000);}catch(Exception e){}

      System.out.println(i.next());

    }

  }

}","Operating System: Linux
Platform: All",,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,29625.0,,,2004-06-23 04:19:24.0,,,false,,,,,,,,,,,,,,18939,,,Thu Jun 24 04:48:57 UTC 2004,,,,,,0|i0sjkv:,164649,,,,,,,,,"23/Jun/04 04:19;scolebourne@joda.org;The code below should throw a ConcurrentModificationException. When using 
collections you are not permitted to iterate and update a collection from 
different threads.

FastArrayList does allow add/remove/clear from different threads, but not 
iteration. This is because iteration is not a single atomic operation.","23/Jun/04 05:18;cooker123456@yahoo.com;What does the below implementation note for the FastArrayList.iterator() method
mean then?

Thanks,
Rob.

IMPLEMENTATION NOTE - If the list is operating in fast mode, an Iterator is
returned, and a structural modification to the list is made, then the Iterator
will continue over the previous contents of the list (at the time that the
Iterator was created), rather than failing due to concurrent modifications.
","23/Jun/04 05:54;scolebourne@joda.org;It looks like your test code has a race condition. The line to setFast(true) is 
after the thread start (which creates the iterator). This might be what you are 
seeing.

In general, we would not advise relying on an implementation note as a 
guarantee of behaviour.","23/Jun/04 07:09;cooker123456@yahoo.com;I just tried several cases including moving the setFast() method prior to the
start(). I also tried not using multiple threads at all.  It simply does not
work... If this is the case it's impossible to loop (thread safely) through all
the elements of the array while in fast mode.  This makes the list fairly useless.

Thanks,
Rob.","24/Jun/04 04:48;scolebourne@joda.org;I took a proper look and found various holes. There was no easy full solution, 
however I have managed to make some simple changes which greatly enhance 
usability.

1) Fast mode SubList iterator add() then set() and add() then remove() now 
works correctly.

2) Fast mode Iterator add() doesn't break the iterator from then on.

3) Fast mode now allows modification EITHER via the Iterator methods OR via the 
List methods. Mixing them gives a ConcurrentModificationException.

4) Some extra tests added.

Change in CVS, but won't be in 3.1 (unless 3.1 has to be rebuilt).
",,,,,,,,,,,,,,,,,,,,,,,,,
[collections] TransformedMap putAll(empty map) causes IllegalArgumentException,COLLECTIONS-48,12342216,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,mlottman@carefx.com,mlottman@carefx.com,30/Apr/05 06:33,15/Mar/08 21:35,10/Jun/19 03:21,15/Mar/08 21:35,3.1,,,,,,,,,,0,,,,"If you create a TransformedMap, and then call map.putAll with an empty map as 
an argument, an IllegalArgumentException is thrown.  putAll should be able to 
handle empty maps without erroring.  The error occurs regardless of whether 
the decorated map has any contents.  The implementation of the Transformers 
attached does not matter.  I am using Java 1.4.2_07.

Example code:
Map map = TransformedMap.decorate(
        new HashMap(),
        TransformerUtils.nopTransformer(),
        TransformerUtils.nopTransformer());

map.putAll(new HashMap()); // This causes IllegalArgumentException!

Fails with the following error:

java.lang.IllegalArgumentException: Initial capacity must be greater than 0
	at org.apache.commons.collections.map.AbstractHashedMap.<init>
(AbstractHashedMap.java:142)
	at org.apache.commons.collections.map.AbstractHashedMap.<init>
(AbstractHashedMap.java:127)
	at org.apache.commons.collections.map.AbstractLinkedMap.<init>
(AbstractLinkedMap.java:95)
	at org.apache.commons.collections.map.LinkedMap.<init>
(LinkedMap.java:78)
	at org.apache.commons.collections.map.TransformedMap.transformMap
(TransformedMap.java:153)
	at org.apache.commons.collections.map.TransformedMap.putAll
(TransformedMap.java:190)
	at net.carefx.contextagent.plugin.ldapuser.PluginTest.main
(PluginTest.java:71)","Operating System: Windows XP
Platform: PC",,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,34686.0,,,2005-05-08 02:14:21.0,,,false,,,,,,,,,,,,,,18950,,,Thu Feb 09 23:44:42 UTC 2006,,,,,,0|i0sjnb:,164660,,,,,,,,,08/May/05 02:14;scolebourne@joda.org;Fixed in SVN revision 169097,09/Feb/06 23:44;gudnabrsam@yahoo.com;*** COM-2746 has been marked as a duplicate of this bug. ***,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] Compile Errors when Importing in VAJ 4,COLLECTIONS-49,12342169,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Won't Fix,,dmueller@electronicpartner.de,dmueller@electronicpartner.de,08/Apr/05 18:48,15/Mar/08 21:35,10/Jun/19 03:21,15/Mar/08 21:35,3.1,,,,,,,,,,0,,,,"Hi,
when I try to import Collections Framework into IBM VisualAge for Java (VAJ) 4,
I get loads of Compile Errors. 
(For your information: VAJ is Java 1.2.2 based...)

Most Errors are in the Testing Framework, so could be ignored.
However, there are quite a few Errors from using 

Entry 

instead of

Map.Entry,

for Example in 

AbstractReferenceMap
    public Object get(Object key) {
        purgeBeforeRead();
        Entry entry = getEntry(key);
        if (entry == null) {
            return null;
        }
        return entry.getValue();
    }

It would be nice for less adventurous users not to have to change the source
code in order to use this in VAJ. 

I can send you the changed sources.

Yours,
David

P.S.: The severity ""major"" is debatable... 8-)","Operating System: Windows 2000
Platform: PC",,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,34368.0,,,2005-05-09 00:21:29.0,,,false,,,,,,,,,,,,,,18949,,,Mon May 23 16:07:57 UTC 2005,,,,,,0|i0sjn3:,164659,,,,,,,,,"08/Apr/05 18:52;dmueller@electronicpartner.de;Oh, I just found out, you could also add an import statement of 

import java.util.Map.Entry;

to the Classes.","09/May/05 00:21;jwcarman;Why do you have to import the source into VAJ in order to use Commons
Collections?  Can't you just use the binary version as a jar file on your classpath?","09/May/05 22:40;dmueller@electronicpartner.de;(In reply to comment #2)
I don't REALLY have to import the source for running the program, but as I was
debugging a shared cache using the LRUMap, I wanted to be able to step into the
collections methods.","23/May/05 03:00;scolebourne@joda.org;The committers of [collections] have no simple means to test this problem (no
VAJ). While we would consider applying a cvs diff -u patch, that would only be a
temporary fix. As soon as we edited the file to make some other fix, the chances
are that we would break the VAJ code again.

Closing as wontfix.","23/May/05 03:13;tomdz;While I'm not directly affected (havn't used VAJ for several years now), I find
this solution unsatisfactory. For one, while this may be a temporary solution it
would be a solution, and when the code gets broken again for VAJ, then another
bug can be raised.
Also, there is at least one easy way to make certain that Entry gets only used
as Map.Entry, and that is by incorporating PMD (http://pmd.sourceforge.net) in
the build process and write a specific rule for Map.Entry. Perhaps David would
volunteer to write this rule ?

WDYT ?
Tom
","23/May/05 04:14;jwcarman;My question is why is this a compile error with one compiler and not with
another?  Which one is correct by the JLS?","23/May/05 04:22;tomdz;This is most likely a bug in VAJ. A subclass inherits all accessible
(non-private) inner classes from its basetype just like it would inherit
accessible fields. Thus for subtypes of Map, its perfectly valid to access Entry
directly without the starting ""Map."".","23/May/05 04:26;jwcarman;So, why should we change code to work around a broken compiler in a tool that
very few folks use anymore?","23/May/05 04:33;tomdz;(In reply to comment #8)

Because its the right thing to do ? David has noted a problem that he has with
commons-collections, and he outlines the solution which is neither complicated
nor does break anything. He probably would even create a patch to fix it (there
shouldn't be too much problematic usages of Map.Entry). So why should we refuse
to incorporate it ?
","23/May/05 07:50;scolebourne@joda.org;As I wrote before, if a patch is supplied, then we may apply it. But I agree
with James that this is low priority. [collections] has very limited committer
time, so sometimes we have to pick and choose which tasks to do.","23/May/05 08:07;tomdz;(In reply to comment #10)
My mistake, it didn't sound like you would accept a patch either.
","23/May/05 16:07;dmueller@electronicpartner.de;I was not aware this is a VAJ issue only, not a JDK 1.2.2 one also. 
Still I think it's worth a patch as soon as I come to do it (haven't done this yet) 
cvs diff -u, you say?
Anyway - I'll try.",,,,,,,,,,,,,,,,,,
[collections] PriorityBuffer iterator does not remove elements properly,COLLECTIONS-42,12342084,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Cannot Reproduce,,bobik72@freenet.de,bobik72@freenet.de,02/Mar/05 01:11,15/Mar/08 21:35,10/Jun/19 03:21,15/Mar/08 21:35,3.1,,,,,,,,,,0,,,,"The following code snippet:

System.out.println(""----------"");
PriorityBuffer s = new PriorityBuffer();
s.add(new Integer(1));
s.add(new Integer(2));
s.add(new Integer(3));
		
for (Iterator it = s.iterator(); it.hasNext(); s.remove() )
	System.out.println(it.next());
System.out.println(""----------"");

Prints this:
----------
1
3
----------
Element 2 is lost, contrary to javadoc of java.util.Iterator","Operating System: All
Platform: All",,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,33791.0,,,2005-03-23 08:06:42.0,,,false,,,,,,,,,,,,,,18956,,,Wed Mar 23 08:06:42 UTC 2005,,,,,,0|i0sjon:,164666,,,,,,,,,"23/Mar/05 08:06;scolebourne@joda.org;The javadoc for PriorityBuffer states that the iterator may return results in a
random order, so there is no issue there.

Your code sample, is repeatable on my system, however it uses the remove method
of the map within the iterator. As a general rule for collections, you may not
alter the collection while you are iterating through it, except via the iterator
remove method.

Thus, I suspect that you reported this because you used s.remove() in the code
example when you should have used it.remove().",,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] TransformedMap.putAll fails with empty Map,COLLECTIONS-30,12342898,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Duplicate,,polx,polx,09/Feb/06 22:45,15/Mar/08 21:35,10/Jun/19 03:21,15/Mar/08 21:35,3.1,,,,,,,,,,0,,,,"Using collections 3.1, TransformedMap.putAll creates a new LinkedMap with the
size of the parameter's collection as capacity. When this size is zero, however,
this raises exceptions.

paul","Operating System: other
Platform: Other",,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,38591.0,,,2006-02-09 23:44:42.0,,,false,,,,,,,,,,,,,,18968,,,Thu Feb 09 23:44:42 UTC 2006,,,,,,0|i0sjrb:,164678,,,,,,,,,"09/Feb/06 23:44;gudnabrsam@yahoo.com;

*** This bug has been marked as a duplicate of 34686 ***",,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] AbstractHashedMap: initial threshold too conservative,COLLECTIONS-33,12342254,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,christian@siefkes.net,christian@siefkes.net,23/May/05 00:28,15/Mar/08 21:35,10/Jun/19 03:21,15/Mar/08 21:35,3.1,,,,,,,,,,0,,,,"The (int initialCapacity, float loadFactor) constructor of
org.apache.commons.collections.map.AbstractHashedMap calculates the initial
resize too threshold conservatively, based on the requested initial capacity
instead of the actually chosen initial capacity (which is round up to the next
power of too). This could be fixed switching two lines to calculating the
initial threshold after rounding up the capacity instead of before:

--- AbstractHashedMap.java      2005-05-22 17:04:23.000000000 +0200
+++ AbstractHashedMap-patched.java      2005-05-22 17:08:46.000000000 +0200
@@ -147,4 +147,4 @@
         this.loadFactor = loadFactor;
-        this.threshold = calculateThreshold(initialCapacity, loadFactor);
         initialCapacity = calculateNewCapacity(initialCapacity);
+        this.threshold = calculateThreshold(initialCapacity, loadFactor);
         this.data = new HashEntry[initialCapacity];

A map with an requested capacity of 600 and a load factor of 0.75, will start
with an initial array of length 1024. Without the fix, the array will be resized
for the first time as soon as there are 450 entries, i.e. the array is less than
45% filled instead of the 75% suggested by the load factor.","Operating System: other
Platform: All",,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,35012.0,,,2005-05-23 02:49:34.0,,,false,,,,,,,,,,,,,,18965,,,Mon May 23 02:49:34 UTC 2005,,,,,,0|i0sjqn:,164675,,,,,,,,,"23/May/05 02:49;scolebourne@joda.org;Patch applied, thanks",,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"[collections] MultiHashMap.remove(key, value) always returns a value",COLLECTIONS-36,12341891,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,tad@tadland.net,tad@tadland.net,24/Nov/04 06:01,15/Mar/08 21:35,10/Jun/19 03:21,15/Mar/08 21:35,3.1,,,,,,,,,,0,,,,"According to the documentation, MultiHashMap.remove(key, value) will only return
a value when it removes a value, null if nothing was removed. Instead, it always
returns a value.","Operating System: Linux
Platform: PC",,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,32366.0,,,2005-01-04 09:13:46.0,,,false,,,,,,,,,,,,,,18962,,,Tue Jan 04 09:13:46 UTC 2005,,,,,,0|i0sjpz:,164672,,,,,,,,,"04/Jan/05 09:13;scolebourne@joda.org;Fixed, thanks",,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] The commons-collections 'binary distro' on the Jakarta Website is actually the 'source distro',COLLECTIONS-37,12341654,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Won't Fix,,d.tonhofer@m-plify.com,d.tonhofer@m-plify.com,23/Aug/04 23:22,15/Mar/08 21:35,10/Jun/19 03:21,15/Mar/08 21:35,3.1,,,,,,,,,,0,,,,The subject says it all,"Operating System: Linux
Platform: PC",,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,30806.0,,,2004-08-24 03:00:15.0,,,false,,,,,,,,,,,,,,18961,,,Wed Aug 25 01:31:26 UTC 2004,,,,,,0|i0sjpr:,164671,,,,,,,,,"24/Aug/04 03:00;scolebourne@joda.org;Can you help me with the URL/link you have trouble with? I can't find anything 
wrong.","24/Aug/04 17:02;d.tonhofer@m-plify.com;That's right, I was not very specific:

If you are on 

http://jakarta.apache.org/commons/collections/

Then click on the left-hand frame's ""Download"" link, you are directed to

http://jakarta.apache.org/site/sourceindex.cgi#commons-collections

instead of

http://jakarta.apache.org/site/binindex.cgi#commons-collections

which is probably not what is intended. ","25/Aug/04 01:31;scolebourne@joda.org;It was exactly what I intended ;-)

The source distro contains the jar file and the source code, which is far more 
useful to plug in to an IDE like Eclipse than the binary distro (ie. you need 
the source code to make the best use of commons IMHO)",,,,,,,,,,,,,,,,,,,,,,,,,,,
"[collections] CollectionUtils.transformedCollection(c,t) doesn't transform the elements of c",COLLECTIONS-46,12341605,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Won't Fix,,gunnar.zarncke@tipp24.de,gunnar.zarncke@tipp24.de,30/Jul/04 19:26,15/Mar/08 21:35,10/Jun/19 03:21,15/Mar/08 21:35,3.1,,,,,,,,,,0,,,,"CollectionUtils.transformedCollection(c,t) doesn't transform the elements of c 
as documented in the API.
The implementation passes this collection to 
TransformedCollection.decorate(collection, transformer) 
and further to
new TransformedCollection(coll, transformer);
where super(c) simply stored it WITHOUT conversion.","Operating System: other
Platform: All",,,,,,,,,,,,04/Aug/04 20:07;cote@computer.org;ASF.LICENSE.NOT.GRANTED--CollectionUtils.diff;https://issues.apache.org/jira/secure/attachment/12333017/ASF.LICENSE.NOT.GRANTED--CollectionUtils.diff,,,1.0,,,,,,,,,,,,,,,,30408.0,,,2004-08-04 00:11:45.0,,,false,,,,,,,,,,,,,,18952,,,Wed Aug 04 20:19:54 UTC 2004,,,,,,0|i0sjnr:,164662,,,,,,,,,"04/Aug/04 00:11;cote@computer.org;I wrote the following test case that seem to confirm the bug :

    public void testTransformedCollection_2() {
        List list = new ArrayList();
        list.add(""1"");
        list.add(""2"");
        list.add(""3"");
        Collection result = CollectionUtils.transformedCollection(list,
TRANSFORM_TO_INTEGER);
        assertTrue(""returned object should be a TransformedCollection"",
            result instanceof TransformedCollection);
        assertEquals(""The transformed collection has the same size"", 3,
result.size());
        assertTrue(""The transformed collection contains the transformation of
the first elements"",result.contains(new Integer(1)));
        assertTrue(""The transformed collection contains the transformation of
the second elements"",result.contains(new Integer(2)));
        assertTrue(""The transformed collection contains the transformation of
the third elements"",result.contains(new Integer(3)));
        assertFalse(""The transformed collection doesn't contain the
transformation of the first elements"",result.contains(""1""));
        assertFalse(""The transformed collection doesn't contain  the
transformation of the second elements"",result.contains(""2""));
        assertFalse(""The transformed collection doesn't contain  the
transformation of the third elements"",result.contains(""3""));
    }

(I will provide a proper patch to TestCollectionUtils.java as soon as I get
cvsgrab working with my proxy.)
","04/Aug/04 01:43;scolebourne@joda.org;The code is working as per the specification, see the factory method:

     * Factory method to create a transforming collection.
     * <p>
     * If there are any elements already in the collection being decorated, they
     * are NOT transformed.

Elements already in the collection when the TransformedCollection is created 
are not transformed.","04/Aug/04 13:58;gunnar.zarncke@tipp24.de;This behavior of not transforming elements already present is not specified in 
the CollectionUtils docs:

http://jakarta.apache.org/commons/collections/apidocs-
COLLECTIONS_3_1/org/apache/commons/collections/CollectionUtils.html#transformedC
ollection(java.util.Collection,%20org.apache.commons.collections.Transformer)

Besides, how else am I supposed to transform (read: map) a Collection other 
than with that method? 

","04/Aug/04 20:07;cote@computer.org;Created an attachment (id=12326)
Comments of the method transformedCollection
","04/Aug/04 20:19;cote@computer.org;I agree with you, it would be better if somebody copy paste the two line saying
that the elements already in the collection being decorated are NOT transformed.
 Actually, I find the javadoc of the method pretty confusing.  I'll try to
improve it and I'll submit a patch.

I don't think there is anything to apply a tranformer to the elements of a
collections. Maybe, you should submit a rfe for a new transformer.",,,,,,,,,,,,,,,,,,,,,,,,,
[collections] Missing putAll(Map map) in MultiHashMap since 3.1,COLLECTIONS-14,12342356,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,sven.macke@rewe.de,sven.macke@rewe.de,06/Jul/05 23:44,15/Mar/08 21:35,10/Jun/19 03:21,15/Mar/08 21:35,3.1,,,,,,,,,,0,,,,"I just upgraded to version 3.1 and noticed some errors in my application. The 
cause is the method putAll(Map map) I used to call on a MultiHashMap to copy to 
content of one to another. That method is not defined in MultiHashMap any more, 
so HashMap.putAll(Map map) is used. The result of that is a MultiHashMap that 
contains ONE value per key and the value itself is a Collection.

Here is some test code I would expect to work, but it fails:

public class MultiHashMapTest extends TestCase
{
    public void testIt()
    {
        MultiMap original = new MultiHashMap();
        original.put(""key"", ""object1"");
        original.put(""key"", ""object2"");

        MultiMap copy = new MultiHashMap();
        copy.putAll(original);

        assertEquals(original.values().size(), copy.values().size());
        assertTrue(copy.containsValue(""object1""));
        assertTrue(copy.containsValue(""object2""));
    }
}","Operating System: Windows 2000
Platform: PC",,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,35631.0,,,2005-07-08 09:04:48.0,,,false,,,,,,,,,,,,,,18984,,,Sun Jul 17 03:10:23 UTC 2005,,,,,,0|i0sjuv:,164694,,,,,,,,,"08/Jul/05 09:04;scolebourne@joda.org;This method was removed in November 2002 as it didn't do anything:
    public void putAll(Map mapToPut) {
        super.putAll(mapToPut);
    }
so, the removal of the method is not the problem.

The problem is that this test case will never have worked.","08/Jul/05 16:50;sven.macke@rewe.de;The test code worked for 2.1 so I had a closer look at the sources. 

You are right, the problem ist NOT the missing method HashMap.putAll(Map map) 
but differences in the implementation of HashMap.put(Object key, Object value). 
In 2.1 there is a check whether ""value"" is an ArrayList (-> call super.put(key, 
value)) or not (-> add value to the interal ArrayList for that key).","17/Jul/05 03:10;scolebourne@joda.org;The put(Object,Object) where value=ArrayList functionality was removed a very
long time ago, what is now svn rv130874 (24th November 2002).

The implementation that was there at that time was broken (it didn't merge
entries, it wiped them), and it was against the Map contract in various ways.

This is also not specified by the MultiMap interface.

However, what I committed to SVN rv209683 will fix the original bug report,
whereby you couldn't clone a multmap using putAll.",,,,,,,,,,,,,,,,,,,,,,,,,,,
[Collections] LazyList throws IndexOutOfBoundsException when trying to set a value out of list bounds,COLLECTIONS-11,12342709,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Cannot Reproduce,,hestonfernandes@yahoo.com,hestonfernandes@yahoo.com,11/Nov/05 01:05,15/Mar/08 21:35,10/Jun/19 03:21,15/Mar/08 21:35,3.1,,,,,,,,,,0,,,,"This was discovered when using struts 1.2.7 with dynamic forms (Tomcat 5.0.24,
jdk 1.4.2). The reset() method in the ActionForm used LazyList.decorate(). 

        if(rooms==null) {
            rooms = new ArrayList();
            roomPrefs.add(""-"");
            roomPrefs = LazyList.decorate(roomPrefs, factory);
        }


However after reset() I get the error below when it tries to initialize the
ArrayList. 

IndexOutOfBoundsException -> Index: 1, Size: 1
java.lang.IndexOutOfBoundsException: Index: 1, Size: 1
	at java.util.ArrayList.RangeCheck(ArrayList.java:507)
	at java.util.ArrayList.set(ArrayList.java:340)
	at
org.apache.commons.collections.list.AbstractListDecorator.set(AbstractListDecorator.java:97)
	at
org.apache.commons.beanutils.PropertyUtilsBean.setIndexedProperty(PropertyUtilsBean.java:1417)
	at org.apache.commons.beanutils.BeanUtilsBean.setProperty(BeanUtilsBean.java:1016)
	at org.apache.commons.beanutils.BeanUtilsBean.populate(BeanUtilsBean.java:811)
	at org.apache.commons.beanutils.BeanUtils.populate(BeanUtils.java:298)
	at org.apache.struts.util.RequestUtils.populate(RequestUtils.java:493)
	at
org.apache.struts.action.RequestProcessor.processPopulate(RequestProcessor.java:805)
	at ....


Possible Solution: For now I've created a class similar to LazyList and have
overridden the set(object, element) method and it has worked. 

    public Object set(int index, Object element) {
        int size = list.size();

        // Grow the list
        if (index >= size) {
            for (int i = size; i <= index; i++) {
                list.add(null);
            }
        }
        return list.set(index, element);
    }

I'm not sure if I'm using LazyList the right way but thought I'd bring it to
your attention.

Thanks!","Operating System: Windows XP
Platform: PC",,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,37450.0,,,2005-11-11 09:12:20.0,,,false,,,,,,,,,,,,,,18987,,,Fri Nov 11 09:12:20 UTC 2005,,,,,,0|i0sjvj:,164697,,,,,,,,,"11/Nov/05 01:10;hestonfernandes@yahoo.com;The correct code that failed was

       if(roomPrefs==null) {
            roomPrefs = new ArrayList();
            roomPrefs.add(""-"");
            roomPrefs = LazyList.decorate(roomPrefs, factory);
        }","11/Nov/05 09:12;scolebourne@joda.org;LazyList is performing as expected. It only expands the list when get(index) is
called.

The class that you want is GrowthList, which expands the list on add() and
set(). (You can decorate with both GrowthList and LazyList together!)

However, GrowthList is unreleased at present, so you will need a nightly build,
or to checkout SVN and build your own jar.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
CompositeSet always supports remove operation,COLLECTIONS-26,12341695,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Fixed,,koji.sekiguchi@bluemartini.com,koji.sekiguchi@bluemartini.com,07/Sep/04 13:38,15/Mar/08 21:35,10/Jun/19 03:21,15/Mar/08 21:35,3.1,,,,,,,,,,0,,,,"CompositeSet javadoc says ""If no strategy is provided then add and remove are
unsupported."" but the class always supports remove operation. The documentation
should be revised as ""If no strategy is provided then add is unsupported.""

regards,

Koji","Operating System: other
Platform: Other",,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,31082.0,,,2004-09-23 06:41:51.0,,,false,,,,,,,,,,,,,,18972,,,Thu Sep 23 06:41:51 UTC 2004,,,,,,0|i0sjs7:,164682,,,,,,,,,"23/Sep/04 06:41;scolebourne@joda.org;Change made, thanks",,,,,,,,,,,,,,,,,,,,,,,,,,,,,
ReferenceMap clears bindings too early,COLLECTIONS-85,12342952,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Invalid,,eric@bodden.de,eric@bodden.de,04/Mar/06 15:58,07/Aug/06 21:08,10/Jun/19 03:21,07/Aug/06 21:08,3.1,,,,,,,Map,,,0,,,,"Hello. This week I had to debug some small example program we are currently 
working on and it really took me a long time to find the actual problem because 
apprently there seems to be a bug in the implementation of ReferenceMap, which 
was really very unexpected for me. To me this seems very critical because I 
reckon that the ReferenceMap is in wide use. Hence I am describing my findings 
in detail.

The code is AspectJ code, but I also provide the bytecode. The puspose of the 
code is to detect the so-called ""lock order reversal pattern"", a temporal event 
pattern which gives indication of potentially unsafe locking. It tries to 
detect patterns where a thread t1 tries to acquire locks in the order l1 l2 and 
another thread t2 tries to do so in the order r2 r1.

When you compile the attached code with the AspectBench compiler (www.
aspectbench.org) and then execute ""java LORTest"", depending on the map 
implementation you choose, one of the following traces is produced:

- ""log"": your commons impl. (Reference identity map with weak key and values)
- ""log_jre"": the JRE impl. (hash map with weak keys, no identity map, but does 
not matter since the keys are threads, which do not implement equals(...))

(Both logs are also in the tarball.)

In log_jre you see that the LOR is detected (at the bottom). That works as 
follows: Whenever a lock is taken, the relationship (thread,lock) is put into a 
first (weak) map (see logging points ""Xa""). Also, for all such relations which 
are contained already, we put a reference to a pair (thread,(lock1,lock2)) into 
a second map (logging points ""Xb""). This represents the information ""thread"" 
took first ""lock1"" then ""lock2"".

As ""log"" shows, the weak map by commons is looses all the sudden some bindings. 
(Compare to log_jre.) This seems really buggy, since subsequent logging output 
shows that the threads and locked resources still exist! 

For me this is fully deterministically reproducable. I am using Windows XP with 
this JRE:

java version ""1.5.0_06""
Java(TM) 2 Runtime Environment, Standard Edition (build 1.5.0_06-b05)
Java HotSpot(TM) Client VM (build 1.5.0_06-b05, mixed mode, sharing)

You can compile the code (using the AspectBench compiler) with ""compile.bat"" or 
you can just run it with ""run.bat"", if you like.","Operating System: Windows XP
Platform: Other",,,,,,,,,,,,04/Mar/06 16:00;eric@bodden.de;ASF.LICENSE.NOT.GRANTED--LORTest - Commons Map.zip;https://issues.apache.org/jira/secure/attachment/12334055/ASF.LICENSE.NOT.GRANTED--LORTest+-+Commons+Map.zip,,,1.0,,,,,,,,,,,,,,,,38853.0,,,2006-03-26 03:20:00.0,,,false,,,,,,,,,,,,,,18913,,,Mon Aug 07 02:43:33 UTC 2006,,,,,,0|i0sjf3:,164623,,,,,,,,,"04/Mar/06 16:00;eric@bodden.de;Created an attachment (id=17835)
The test case.

The zip file contains the sources and the compiled classes along with two batch
files to recompile and run the files. Also the zip included two dumps, one with
the commons map and one with the JRE map.","26/Mar/06 03:20;scolebourne@joda.org;Thanks for the report.

Unfortunately, it hasn't helper me understand the issue particularly. I can
reproduce the trace you supply (note that log_jre is missing from the zip).
However, this doesn't help me understand what is going on.

For a start, I can't even find the piece of code where the commons ReferenceMap
is being created. I can't see what sequence of operations is being called, etc.

This is a general problem with aspects - they break so much of what programmers
expect from Java.

In fact, I believe that this is just a special example of not correctly
synchronizing the ReferenceMap implementation. For example, here is the javadoc
of the purge mathod:
    /**
     * Purges stale mappings from this map.
     * <p>
     * Note that this method is not synchronized!  Special
     * care must be taken if, for instance, you want stale
     * mappings to be removed on a periodic basis by some
     * background thread.
     */

And the javadoc from the top of the class:
 * This implementation is not synchronized.
 * You can use {@link java.util.Collections#synchronizedMap} to 
 * provide synchronized access to a <code>ReferenceMap</code>.


Basically, ReferenceMap has no synchronization, and no thread handling. Its only
interaction with threads is via the standard JDK API on a ReferenceQueue.
","27/Mar/06 19:17;eric@bodden.de;Ok, thanks for the hint. That could of course be an issue. I will try to verify 
this. Sorry about the AspectJ code - but there's not much to do about it. I 
will report back in a bit.

",19/Jul/06 21:59;scolebourne;Awaiting feedback - I will close as unreproducible otherwise,07/Aug/06 02:43;eric@bodden.de;Hello. This was indeed apparently due to a lack of synchronization. My apologies for not noticing that earlier and for the late reply.,,,,,,,,,,,,,,,,,,,,,,,,,
ListOrderedSet add results in separate objects in set/list if equal,COLLECTIONS-12,12342673,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Major,Cannot Reproduce,scolebourne,genekhart@hotmail.com,genekhart@hotmail.com,03/Nov/05 07:59,19/Jul/06 22:01,10/Jun/19 03:21,19/Jul/06 22:01,3.1,,,,,,,Set,,,0,,,,"If you add an object to ListOrderedSet, and then try to replace the object with
add and the objects are different but equals() is true, you will have two
different objects in the internal list and set so after you do an add, doing a
listorderedset.get(i) will return the old object.","Operating System: other
Platform: Other",,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,37338.0,,,2005-11-04 08:05:20.0,,,false,,,,,,,,,,,,,,18986,,,Wed Jul 19 22:01:33 UTC 2006,,,,,,0|i0sjvb:,164696,,,,,,,,,"04/Nov/05 08:05;scolebourne@joda.org;What implementations of Map and List are you using? This all works fine with a
HashMap and ArrayList.

Note that the functionality is to NOT replace the object in either the list or
map (as per the specification of Set).",19/Jul/06 22:01;scolebourne;With no test case or additional information I am closing this call,,,,,,,,,,,,,,,,,,,,,,,,,,,,
LRUMap constructor javadoc and behavior are inconsistent (maxSize cannot be less than 0),COLLECTIONS-316,12414517,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Minor,Fixed,,os111,os111,10/Feb/09 21:55,09/Nov/14 14:31,10/Jun/19 03:21,28/Feb/13 20:04,3.1,,,,,4.0,4.0-alpha1,Map,,,0,,,,"The LRUMap constructor specifies ""@param maxSize  the maximum size of the map, -1 for no limit""

The first line is then:

        if (maxSize < 1) {
            throw new IllegalArgumentException(""LRUMap max size must be greater than 0"");
        }

There is nothing wrong with allowing a negative maxSize. This way the map can be used to order elements relative to access time. I think the above code should be remove and the javadoc should stay the same.",n/a,60,60,,0%,60,60,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2009-05-20 04:22:33.823,,,false,,,,,,,,,,,,,,18685,,,Wed May 20 04:22:33 UTC 2009,,,,,,0|i0si67:,164421,,,,,,,,,"20/May/09 04:22;bayard;Two of the javadocs say it will throw the exception. One of them is the one you quote.

The code before the exception tries to make maxSize be DEFAULT_CAPACITY, so the no limit part would also be wrong.

I've removed the ""-1 means no limit"" from the Javadoc in r776538.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,
AbstractCollectionDecorator is inconsistent with AbstractListDecorator. Uses private member variable instead of protected getter,COLLECTIONS-352,12455936,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Minor,Fixed,,agent,agent,10/Feb/10 20:34,09/Nov/14 14:31,10/Jun/19 03:21,28/Feb/13 20:05,3.0,3.1,3.2,,,4.0,4.0-alpha1,Collection,,,0,,,,"AbstractListDecorator uses getList() to access its private member variable for its methods:
{code}
    public int indexOf(Object object) {
        return getList().indexOf(object);
    }
{code}

Which allows me to almost do something like this (notice I'm taking some liberties here with the no-arg serialization constructor):

{code}
    public static class FutureList<T> extends AbstractListDecorator {

        private Future<List<T>> futureList;

        public FutureList(Future<List<T>> futureList)
        {
            super();
            this.futureList = futureList;
        }

        @Override
        protected Collection<T> getCollection()
        {
            try
            {
                return futureList.get();
            }
            catch (InterruptedException e)
            {
                throw new RuntimeException(e);
            }
            catch (ExecutionException e)
            {
                throw new RuntimeException(e);
            }
        }
    }
{code}

But AbstractCollectionDecorator uses its private member variable
{code}
    public boolean add(Object object) {
        return collection.add(object);
    }
{code}

When it should be IMHO:

{code}
    public boolean add(Object object) {
        return getCollection().add(object);
    }
{code}

Of course most everybody has an armpit and an opinion :) ",,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,2010-06-19 19:25:59.399,,,false,,,,,,,,,,,,,,18651,,,Sat Jun 19 19:25:59 UTC 2010,,,,,,0|i0shzz:,164393,,,,,,,,,19/Jun/10 19:25;bayard;4.0 uses decorated() and both classes are using it instead of the private variable.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] PriorityBuffer does not implement Serializable,COLLECTIONS-67,12342462,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Minor,Fixed,,sphelps@csc.liv.ac.uk,sphelps@csc.liv.ac.uk,12/Aug/05 23:42,15/Mar/08 21:35,10/Jun/19 03:21,15/Mar/08 21:35,3.1,,,,,,,,,,0,,,,"The class org.apache.commons.collections.buffer.PriorityBuffer does not
implement java.io.Serializable","Operating System: other
Platform: Other",,,,,,,,,,,,12/Aug/05 23:43;sphelps@csc.liv.ac.uk;ASF.LICENSE.NOT.GRANTED--PriorityBuffer.java.patch;https://issues.apache.org/jira/secure/attachment/12333706/ASF.LICENSE.NOT.GRANTED--PriorityBuffer.java.patch,12/Aug/05 23:45;sphelps@csc.liv.ac.uk;ASF.LICENSE.NOT.GRANTED--TestPriorityBuffer.java.patch;https://issues.apache.org/jira/secure/attachment/12333707/ASF.LICENSE.NOT.GRANTED--TestPriorityBuffer.java.patch,,2.0,,,,,,,,,,,,,,,,36163.0,,,2005-10-08 21:51:33.0,,,false,,,,,,,,,,,,,,18931,,,Sat Oct 08 21:51:33 UTC 2005,,,,,,0|i0sjj3:,164641,,,,,,,,,"12/Aug/05 23:43;sphelps@csc.liv.ac.uk;Created an attachment (id=16019)
patch to make PriorityBuffer implement the Serializable interface

patch in unified format to make PriorityBuffer implement the Serializable
interface.  The class now implements Serializable and declares a
serialVersionUID field.","12/Aug/05 23:45;sphelps@csc.liv.ac.uk;Created an attachment (id=16020)
patch to org.apache.commons.collections.TestPriorityBuffer class

A new method 'testSerialization()' has been added which tests that heaps can be
serialized and restored safely.","08/Oct/05 21:51;scolebourne@joda.org;Change made (your patch was backwards, removing the code, not adding it)
thanks",,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] ExtendedProperties should not just allow NPEs,COLLECTIONS-39,12341617,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Minor,Fixed,,john.tal@gxs.com,john.tal@gxs.com,06/Aug/04 01:23,15/Mar/08 21:35,10/Jun/19 03:21,15/Mar/08 21:35,3.1,,,,,,,,,,0,,,,"Its really an annoyance because I frequently have my debugger stop on
NullPointerException.

ExtendedProperties.readProperty

Change from         
                    String line = readLine().trim();
to
                    String line = readLine();
                    if(line != null) line = line.trim(); else return null;

Also in ExtendedProperties.load

            while (true) {
                String line = reader.readProperty();
				if(line == null)
					return;
                int equalSign = line.indexOf('=');","Operating System: other
Platform: Other",,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,30497.0,,,2004-09-23 06:37:23.0,,,false,,,,,,,,,,,,,,18959,,,Thu Sep 23 06:37:23 UTC 2004,,,,,,0|i0sjpb:,164669,,,,,,,,,23/Sep/04 06:37;scolebourne@joda.org;Changes made to avoid NPE in normal processing,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] ListOrderedSet broken or documentation wrong.,COLLECTIONS-18,12341853,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Minor,Fixed,,rlenard,rlenard,05/Nov/04 08:45,15/Mar/08 21:35,10/Jun/19 03:21,15/Mar/08 21:35,3.1,,,,,,,,,,0,,,,"The method ListOrderedSet.decorate(List list) ""decorates"" the list, implying 
that it leaves the underlying list un-modified.  But this is just not true - it 
requires a modifiable List so it can remove duplicates.  It should at least 
warn about this - so you don't have to look in the code to see how it works and 
see why it fails when using an unmodifiable list (such as given by 
java.util.Collections.unmodifiableList()).

Actually it'd be good to have a variant that worked with unmodifiable lists.","Operating System: other
Platform: All",,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,32073.0,,,2005-01-04 09:02:21.0,,,false,,,,,,,,,,,,,,18980,,,Tue Jan 04 09:02:21 UTC 2005,,,,,,0|i0sjtz:,164690,,,,,,,,,"04/Jan/05 09:02;scolebourne@joda.org;The class is behaving as intended,, although I can see why you might have been
confused. I have added extra javadoc.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[collections] Javadoc entry page overview has bad links for 'Transformer' and 'Factory',COLLECTIONS-38,12342281,Bug,Closed,COLLECTIONS,Commons Collections,software,issues@commons.apache.org,,http://commons.apache.org/collections/,Trivial,Fixed,,andreas.przygienda@zkb.ch,andreas.przygienda@zkb.ch,02/Jun/05 22:04,15/Mar/08 21:35,10/Jun/19 03:21,15/Mar/08 21:35,3.1,,,,,,,,,,0,,,,"the overview in the entry page of the collections API javadoc has bad links in 
the description of the ""org.apache.commons.collections.functors"" package.
(*...* means an underlying link):

""This package contains implementations of the *Closure*, *Predicate*, 
*Transformer* and *Factory* interfaces.""

*Transformer* and *Factory* link to the Predicate Interface","Operating System: All
Platform: All",,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,35186.0,,,2005-06-07 08:05:11.0,,,false,,,,,,,,,,,,,,18960,,,Tue Jun 07 08:05:11 UTC 2005,,,,,,0|i0sjpj:,164670,,,,,,,,,07/Jun/05 08:05;scolebourne@joda.org;Fixed thanks,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
